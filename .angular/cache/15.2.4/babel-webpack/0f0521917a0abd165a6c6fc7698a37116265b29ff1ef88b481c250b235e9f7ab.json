{"ast":null,"code":"import { EventEmitter, ElementRef } from '@angular/core';\nimport { ReplaySubject, Subject } from 'rxjs';\nimport { takeUntil, tap, map, filter, combineLatest, withLatestFrom } from 'rxjs/operators';\n/** Animación para mostrar los bloques */\nimport { pulseListItem } from '../../shared/animations';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../../plumb.service\";\nimport * as i2 from \"../../theme-manager.service\";\nimport * as i3 from \"@angular/common\";\nimport * as i4 from \"./designer-render-body-block/designer-render-body-block.component\";\nimport * as i5 from \"../../safe-style.pipe\";\nconst _c0 = [\"plumbCanvas\"];\nconst _c1 = [\"blockList\"];\nconst _c2 = function () {\n  return {};\n};\nfunction DesignerRenderBodyComponent_ng_container_4_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r7 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementContainerStart(0, null, 5);\n    i0.ɵɵelementStart(2, \"ios-designer-render-body-block\", 6);\n    i0.ɵɵlistener(\"delete\", function DesignerRenderBodyComponent_ng_container_4_ng_container_1_Template_ios_designer_render_body_block_delete_2_listener($event) {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r6 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r6.deleteBlock($event));\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const block_r4 = ctx.$implicit;\n    const render_r2 = i0.ɵɵnextContext().ngIf;\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"@pulseListItem\", undefined)(\"focused\", render_r2.focused && render_r2.focused.indexOf(block_r4.uuid) > -1)(\"openForConnection\", ctx_r3.openForDrop.indexOf(block_r4.uuid) > -1)(\"closedForConnection\", ctx_r3.closedForDrop.indexOf(block_r4.uuid) > -1)(\"block\", block_r4)(\"layout\", render_r2.layout[block_r4.uuid] ? render_r2.layout[block_r4.uuid] : i0.ɵɵpureFunction0(6, _c2));\n  }\n}\nfunction DesignerRenderBodyComponent_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, DesignerRenderBodyComponent_ng_container_4_ng_container_1_Template, 3, 7, \"ng-container\", 4);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const render_r2 = ctx.ngIf;\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", render_r2.blocks)(\"ngForTrackBy\", ctx_r1.getBlockId);\n  }\n}\nconst _c3 = function (a0) {\n  return {\n    transform: a0\n  };\n};\nexport let DesignerRenderBodyComponent = /*#__PURE__*/(() => {\n  class DesignerRenderBodyComponent {\n    /**\r\n     * Edges en el flujo\r\n    */\n    set edges(newEdges) {\n      console.log('llegaron nuevos edges-->', newEdges);\n      this.edges$.next(newEdges);\n    }\n    /**\r\n     * Bloque que se deben resaltar en el flujo\r\n    */\n    set focused(list) {\n      console.log('llegaron nuevos focused-->', list);\n      this.focused$.next(list);\n    }\n    /**\r\n     * Lista de bloques en el documento\r\n    */\n    set blocksValue(list) {\n      this.blocks$.next(list);\n      this.blocks = list;\n    }\n    /**\r\n     * Lista de bloques disponibles\r\n    */\n    set availablesBlocks(list) {\n      this.catalog$.next(list);\n    }\n    /**\r\n     * Theme utilizado en el canvas\r\n    */\n    set themeCss(theme) {\n      /** Obtenemos las propiedades del nuevo theme */\n      const properties = this.themeSrv.getThemeProperties(theme);\n      /** Asignamos las propiedades en el template */\n      this.themeProperties = properties;\n    }\n    /**\r\n     * Nivel de zoom para mostrar el canvas\r\n    */\n    set zoomValue(value) {\n      this.zoom = value;\n      this.plumbSrv.setZoom(value);\n    }\n    /**\r\n     * Tipo de conector para usar en jsplumb\r\n    */\n    set connectorType(connector) {\n      if (!connector) {\n        return;\n      }\n      this.plumbSrv.setConnectorType(connector);\n    }\n    /**\r\n     * Layout para mostrar los bloques\r\n    */\n    set layout(newLayouts) {\n      this.layout$.next(newLayouts);\n    }\n    /**\r\n     * Constructor del componente\r\n     */\n    constructor(plumbSrv, changeDetectorRef, themeSrv) {\n      this.plumbSrv = plumbSrv;\n      this.changeDetectorRef = changeDetectorRef;\n      this.themeSrv = themeSrv;\n      /**\r\n       * Subject para manejar destrucción del objeto\r\n      */\n      this.componentDestroyed$ = new Subject();\n      /**\r\n       * Stream con cambios en la lista de nodos\r\n       */\n      this.blocks$ = new ReplaySubject(1);\n      /**\r\n       * Stream con cambios en el catálogo\r\n       */\n      this.catalog$ = new ReplaySubject(1);\n      /**\r\n       * Stream para notificar init del componente\r\n       */\n      this.init$ = new ReplaySubject(1);\n      /**\r\n       * Stream para notificar nuevos edges\r\n       */\n      this.edges$ = new ReplaySubject(1);\n      /**\r\n       * Stream para notificar nuevos layout\r\n       */\n      this.layout$ = new ReplaySubject(1);\n      /**\r\n       * Stream para notificar nuevos blocks que se deben \"enfocar\"\r\n       */\n      this.focused$ = new ReplaySubject(1);\n      /**\r\n       * Copia local de los blocks\r\n       */\n      this.blocks = [];\n      /**\r\n       * Lista de bloqueIds que están \"abiertos\" para dropear una conexión\r\n       */\n      this.openForDrop = [];\n      /**\r\n       * Lista de bloqueIds que están \"cerrados\" para dropear una conexión\r\n       */\n      this.closedForDrop = [];\n      /**\r\n       * Propiedades del theme aplicado actualmente\r\n       */\n      this.themeProperties = '';\n      /**\r\n       * Nivel de zoom utilizado\r\n       */\n      this.zoom = 1;\n      /**\r\n       * Enviar evento para eliminar un bloque\r\n       */\n      this.delete = new EventEmitter();\n      /**\r\n       * Enviar evento para Draggear un bloque\r\n       */\n      this.insert = new EventEmitter();\n      /**\r\n       * Enviar evento para Duplicar un bloque\r\n       */\n      this.duplicate = new EventEmitter();\n      /**\r\n       * Enviar evento para Mover un bloque\r\n       */\n      this.move = new EventEmitter();\n      /**\r\n       * Enviar evento para Inspeccionar un bloque\r\n       */\n      this.inspectBlock = new EventEmitter();\n      /**\r\n       * Evento para notificar cambios en edges\r\n      */\n      this.edgeAdded = new EventEmitter();\n      /**\r\n       * Evento para notificar cambios en edges\r\n      */\n      this.edgeDetached = new EventEmitter();\n      /**\r\n       * Evento para notificar cambios en el layout\r\n      */\n      this.layoutChanged = new EventEmitter();\n      /**\r\n       * Stream para redibujar bloques en el template\r\n       * La suscripción se realiza en el template con async\r\n       */\n      this.renderValueChanges$ = this.init$.pipe(tap(() => {\n        /** Establecemos el elemento que contiene al plumbing */\n        this.plumbSrv.setContainer(this.plumbCanvas.nativeElement);\n      }), combineLatest(this.blocks$, this.edges$, this.layout$, this.focused$), map(([init, blocks, edges, layout, focused]) => ({\n        blocks: blocks,\n        layout: layout,\n        edges: edges,\n        focused: focused\n      })));\n      /**\r\n       * Stream para resincronizar cambios en edges o layout\r\n       */\n      const repaint$ = this.init$.pipe(takeUntil(this.componentDestroyed$), combineLatest(this.edges$, this.layout$), tap(([init, edges, layout]) => {\n        setTimeout(() => {\n          this.plumbSrv.sync(this.blocks, edges);\n        });\n      })).subscribe();\n      /**\r\n       * Nos suscribimos a los eventos de dragado de la conexión\r\n       * se utilizan para calcular los bloques\r\n       * disponibles (abiertos y cerrados) para la conexión\r\n       */\n      /* Comienzo del dragado de conexión */\n      const dragStart$ = this.plumbSrv.dragStart$.pipe(takeUntil(this.componentDestroyed$), tap(list => {\n        this.openForDrop = list.open;\n        this.closedForDrop = list.closed;\n      }), tap(() => this.changeDetectorRef.markForCheck())).subscribe();\n      /* Fin del dragado de conexión */\n      const dragStop$ = this.plumbSrv.dragStop$.pipe(takeUntil(this.componentDestroyed$), tap(() => {\n        this.openForDrop = [];\n        this.closedForDrop = [];\n      }), tap(() => this.changeDetectorRef.markForCheck())).subscribe();\n      /** Nos suscribimos al evento de nueva conexiones */\n      const connectionAdded$ = this.plumbSrv.connectionAdded$.pipe(takeUntil(this.componentDestroyed$), filter(event => event.type === 'user'), map(event => event.edge), tap(configuration => this.edgeAdded.emit({\n        edge: configuration\n      }))).subscribe();\n      /** Nos suscribimos al evento de eliminación de conexión */\n      const connectionDetached$ = this.plumbSrv.connectionDetached$.pipe(takeUntil(this.componentDestroyed$), filter(event => event.type === 'user'), map(event => event.edge), tap(configuration => this.edgeDetached.emit({\n        edge: configuration\n      }))).subscribe();\n      /** Nos suscribimos al evento de cambio de posición en un bloque */\n      const changePosition$ = this.plumbSrv.changePosition$.pipe(takeUntil(this.componentDestroyed$), map(event => ({\n        [event.blockid]: {\n          top: event.top,\n          left: event.left\n        }\n      })), tap(layout => this.layoutChanged.emit({\n        layout: layout\n      }))).subscribe();\n    }\n    /**\r\n     * Elimina un bloque del flujo\r\n     */\n    deleteBlock($event) {\n      /** Notificamos la eliminación del bloque */\n      this.delete.emit($event);\n    }\n    /**\r\n     * Devuelve el id de un bloque\r\n     * Utilizada desde el template para el trackBy\r\n     * de la lista de bloques\r\n     */\n    getBlockId(index, item) {\n      return item.uuid;\n    }\n    /**\r\n     * Handler para el evento de inicialización de la vista\r\n     */\n    ngAfterViewInit() {\n      /** Notificamos que se inicializó */\n      this.init$.next(null);\n      /**\r\n       * Nos suscribimos a los cambios en la lista de bloques\r\n       * ViewChildren sólo está disponible\r\n       * cuando se inicializa la vista\r\n       *\r\n       * Sólo se sincroniza con jsPlumb cuándo\r\n       * se cambia la lista de bloques\r\n       *\r\n       */\n      const readyToPlumb$ = this.blockList.changes.pipe(takeUntil(this.componentDestroyed$), withLatestFrom(this.renderValueChanges$), map(([queryList, combo]) => combo), filter(combo => combo && combo.blocks), tap(combo => {\n        this.plumbSrv.sync(combo.blocks, combo.edges);\n      })).subscribe();\n    }\n    /**\r\n     * Destructor del componente\r\n     * Completa el stream para notificar que se está destruyendo\r\n     */\n    ngOnDestroy() {\n      /** Stream para notificar destrucción del componente */\n      this.componentDestroyed$.next();\n      this.componentDestroyed$.complete();\n    }\n  }\n  DesignerRenderBodyComponent.ɵfac = function DesignerRenderBodyComponent_Factory(t) {\n    return new (t || DesignerRenderBodyComponent)(i0.ɵɵdirectiveInject(i1.PlumbService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i2.ThemeManagerService));\n  };\n  DesignerRenderBodyComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: DesignerRenderBodyComponent,\n    selectors: [[\"ios-designer-render-body\"]],\n    viewQuery: function DesignerRenderBodyComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 7, ElementRef);\n        i0.ɵɵviewQuery(_c1, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.plumbCanvas = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.blockList = _t);\n      }\n    },\n    inputs: {\n      blockDefinition: \"blockDefinition\",\n      edges: \"edges\",\n      focused: \"focused\",\n      types: \"types\",\n      blocksValue: [\"blocks\", \"blocksValue\"],\n      availablesBlocks: \"availablesBlocks\",\n      selected: \"selected\",\n      themeCss: \"themeCss\",\n      zoomValue: [\"zoom\", \"zoomValue\"],\n      connectorType: \"connectorType\",\n      layout: \"layout\"\n    },\n    outputs: {\n      delete: \"delete\",\n      insert: \"insert\",\n      duplicate: \"duplicate\",\n      move: \"move\",\n      inspectBlock: \"inspectBlock\",\n      edgeAdded: \"edgeAdded\",\n      edgeDetached: \"edgeDetached\",\n      layoutChanged: \"layoutChanged\"\n    },\n    decls: 6,\n    vars: 9,\n    consts: [[1, \"render-body-wrapper\"], [\"id\", \"plumbCanvas\", 1, \"canvas\", 3, \"ngStyle\"], [\"plumbCanvas\", \"\"], [4, \"ngIf\"], [4, \"ngFor\", \"ngForOf\", \"ngForTrackBy\"], [\"blockList\", \"\"], [3, \"focused\", \"openForConnection\", \"closedForConnection\", \"block\", \"layout\", \"delete\"]],\n    template: function DesignerRenderBodyComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵpipe(1, \"safeStyle\");\n        i0.ɵɵelementStart(2, \"div\", 1, 2);\n        i0.ɵɵtemplate(4, DesignerRenderBodyComponent_ng_container_4_Template, 2, 2, \"ng-container\", 3);\n        i0.ɵɵpipe(5, \"async\");\n        i0.ɵɵelementEnd()();\n      }\n      if (rf & 2) {\n        i0.ɵɵattribute(\"style\", i0.ɵɵpipeBind1(1, 3, ctx.themeProperties), i0.ɵɵsanitizeStyle);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngStyle\", i0.ɵɵpureFunction1(7, _c3, \"scale(\" + ctx.zoom + \")\"));\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", i0.ɵɵpipeBind1(5, 5, ctx.renderValueChanges$));\n      }\n    },\n    dependencies: [i3.NgForOf, i3.NgIf, i3.NgStyle, i4.DesignerRenderBodyBlockComponent, i3.AsyncPipe, i5.SafeStylePipe],\n    styles: [\"ios-designer-render-body{--canvas-expiration-color: #FC7753;--canvas-exit-label: #66A182;--canvas-grid-background-color: #f8f6f6;--canvas-grid-point-color: #bebfc0;--canvas-endpoint-color: #ccc;--canvas-connector-color: #ccc;--canvas-block-action-background-color: #7286A0;--canvas-block-action-color: white;--canvas-block-start-background-color: #F7EF99;--canvas-block-start-color: grey;--canvas-block-signal-background-color: #F7EF99;--canvas-block-signal-color: grey;--canvas-block-end-background-color: #D4F5F5;--canvas-block-end-color: grey;--canvas-block-node-background-color: #BEB7A4;--canvas-block-node-color: #fefefe;--canvas-block-note-background-color: #FCFC62;--canvas-block-note-color: #4B4B4B;--canvas-block-border-focused: red}.render-body-wrapper{overflow:scroll;width:100%;height:500px;position:relative}.canvas{position:absolute;width:1920px;height:1080px;transition:transform .3s ease-out;transform-origin:top left;background:linear-gradient(90deg,var(--canvas-grid-background-color) 18px,transparent 1%) center,linear-gradient(var(--canvas-grid-background-color) 18px,transparent 1%) center,var(--canvas-grid-point-color);background-size:20px 20px}.jtk-overlay.connector-expiration-label,.jtk-overlay.connector-exit-label{font-size:14px;padding:4px;border-radius:50%;min-width:20px;min-height:20px;text-align:center}.jtk-overlay.connector-expiration-label{z-index:1000;background-color:var(--canvas-expiration-color);cursor:pointer}.jtk-overlay.connector-exit-label{z-index:1000;background-color:var(--canvas-exit-label);cursor:pointer}.jtk-endpoint{z-index:1000;cursor:grab;opacity:0;animation-delay:.2s;animation-name:endpointFadeIn;animation-duration:1s;animation-fill-mode:forwards}.jtk-connector.programatic-connector path:nth-child(2),.jtk-overlay.connector-exit-label,.jtk-overlay.connector-expiration-label{opacity:0;animation-delay:1s;animation-name:endpointFadeIn;animation-duration:1s;animation-fill-mode:forwards}@keyframes endpointFadeIn{0%{opacity:0}to{opacity:1}}.jtk-endpoint.jtk-dragging{cursor:grabbing}.jtk-drag-select{-webkit-user-select:none;user-select:none}.jtk-endpoint svg{filter:drop-shadow(3px 3px 2px rgba(0,0,0,.7))}.jtk-endpoint.jtk-endpoint-full svg{filter:unset}.jtk-endpoint.jtk-endpoint-full{cursor:auto;z-index:10}.jtk-endpoint.endpoint-action-out svg *,.jtk-endpoint.endpoint-signal-out svg *,.jtk-endpoint.endpoint-start-out svg *{fill:var(--canvas-endpoint-color)}.jtk-endpoint.endpoint-node-out svg *{fill:var(--canvas-exit-label)}.jtk-endpoint.endpoint-node-expiration svg *{fill:var(--canvas-expiration-color)}.jtk-connector{cursor:pointer}.jtk-connector.programatic-connector path:nth-child(1){stroke-dasharray:1000;stroke-dashoffset:1000;animation-name:expand-connection;animation-delay:.5s;animation-timing-function:ease-out;animation-fill-mode:forwards}@keyframes expand-connection{to{stroke-dashoffset:0}}.jtk-connector.connection-marked-for-delete path:nth-child(1){animation-name:retract-connection;animation-delay:.0s;animation-timing-function:ease-out;animation-fill-mode:backwards;animation-direction:reverse}@keyframes retract-connection{to{stroke-dashoffset:0}}.jtk-connector.connection-marked-for-delete path:nth-child(2){visibility:hidden}.jtk-connector path:nth-child(1){stroke:var(--canvas-connector-color)}.jtk-connector path:nth-child(2){stroke:var(--canvas-connector-color);fill:var(--canvas-connector-color)}\\n\"],\n    encapsulation: 2,\n    data: {\n      animation: [pulseListItem]\n    },\n    changeDetection: 0\n  });\n  return DesignerRenderBodyComponent;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}