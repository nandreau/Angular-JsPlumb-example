{"ast":null,"code":"var _classPrivateMethodInitSpec = require(\"C:/Users/nandr/Documents/Projets taf/jsplump ex/node_modules/@babel/runtime/helpers/classPrivateMethodInitSpec.js\").default;\nvar _classPrivateFieldInitSpec = require(\"C:/Users/nandr/Documents/Projets taf/jsplump ex/node_modules/@babel/runtime/helpers/classPrivateFieldInitSpec.js\").default;\nvar _classPrivateMethodGet = require(\"C:/Users/nandr/Documents/Projets taf/jsplump ex/node_modules/@babel/runtime/helpers/classPrivateMethodGet.js\").default;\nvar _classPrivateFieldGet = require(\"C:/Users/nandr/Documents/Projets taf/jsplump ex/node_modules/@babel/runtime/helpers/classPrivateFieldGet.js\").default;\nvar _arr = /*#__PURE__*/new WeakMap();\nvar _keyIndices = /*#__PURE__*/new WeakMap();\nvar _heapify = /*#__PURE__*/new WeakSet();\nvar _decrease = /*#__PURE__*/new WeakSet();\nvar _swap = /*#__PURE__*/new WeakSet();\n/**\n * A min-priority queue data structure. This algorithm is derived from Cormen,\n * et al., \"Introduction to Algorithms\". The basic idea of a min-priority\n * queue is that you can efficiently (in O(1) time) get the smallest key in\n * the queue. Adding and removing elements takes O(log n) time. A key can\n * have its priority decreased in O(log n) time.\n */\nclass PriorityQueue {\n  constructor() {\n    _classPrivateMethodInitSpec(this, _swap);\n    _classPrivateMethodInitSpec(this, _decrease);\n    _classPrivateMethodInitSpec(this, _heapify);\n    _classPrivateFieldInitSpec(this, _arr, {\n      writable: true,\n      value: []\n    });\n    _classPrivateFieldInitSpec(this, _keyIndices, {\n      writable: true,\n      value: {}\n    });\n  }\n  /**\n   * Returns the number of elements in the queue. Takes `O(1)` time.\n   */\n  size() {\n    return _classPrivateFieldGet(this, _arr).length;\n  }\n\n  /**\n   * Returns the keys that are in the queue. Takes `O(n)` time.\n   */\n  keys() {\n    return _classPrivateFieldGet(this, _arr).map(function (x) {\n      return x.key;\n    });\n  }\n\n  /**\n   * Returns `true` if **key** is in the queue and `false` if not.\n   */\n  has(key) {\n    return _classPrivateFieldGet(this, _keyIndices).hasOwnProperty(key);\n  }\n\n  /**\n   * Returns the priority for **key**. If **key** is not present in the queue\n   * then this function returns `undefined`. Takes `O(1)` time.\n   *\n   * @param {Object} key\n   */\n  priority(key) {\n    var index = _classPrivateFieldGet(this, _keyIndices)[key];\n    if (index !== undefined) {\n      return _classPrivateFieldGet(this, _arr)[index].priority;\n    }\n  }\n\n  /**\n   * Returns the key for the minimum element in this queue. If the queue is\n   * empty this function throws an Error. Takes `O(1)` time.\n   */\n  min() {\n    if (this.size() === 0) {\n      throw new Error(\"Queue underflow\");\n    }\n    return _classPrivateFieldGet(this, _arr)[0].key;\n  }\n\n  /**\n   * Inserts a new key into the priority queue. If the key already exists in\n   * the queue this function returns `false`; otherwise it will return `true`.\n   * Takes `O(n)` time.\n   *\n   * @param {Object} key the key to add\n   * @param {Number} priority the initial priority for the key\n   */\n  add(key, priority) {\n    var keyIndices = _classPrivateFieldGet(this, _keyIndices);\n    key = String(key);\n    if (!keyIndices.hasOwnProperty(key)) {\n      var arr = _classPrivateFieldGet(this, _arr);\n      var index = arr.length;\n      keyIndices[key] = index;\n      arr.push({\n        key: key,\n        priority: priority\n      });\n      _classPrivateMethodGet(this, _decrease, _decrease2).call(this, index);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Removes and returns the smallest key in the queue. Takes `O(log n)` time.\n   */\n  removeMin() {\n    _classPrivateMethodGet(this, _swap, _swap2).call(this, 0, _classPrivateFieldGet(this, _arr).length - 1);\n    var min = _classPrivateFieldGet(this, _arr).pop();\n    delete _classPrivateFieldGet(this, _keyIndices)[min.key];\n    _classPrivateMethodGet(this, _heapify, _heapify2).call(this, 0);\n    return min.key;\n  }\n\n  /**\n   * Decreases the priority for **key** to **priority**. If the new priority is\n   * greater than the previous priority, this function will throw an Error.\n   *\n   * @param {Object} key the key for which to raise priority\n   * @param {Number} priority the new priority for the key\n   */\n  decrease(key, priority) {\n    var index = _classPrivateFieldGet(this, _keyIndices)[key];\n    if (priority > _classPrivateFieldGet(this, _arr)[index].priority) {\n      throw new Error(\"New priority is greater than current priority. \" + \"Key: \" + key + \" Old: \" + _classPrivateFieldGet(this, _arr)[index].priority + \" New: \" + priority);\n    }\n    _classPrivateFieldGet(this, _arr)[index].priority = priority;\n    _classPrivateMethodGet(this, _decrease, _decrease2).call(this, index);\n  }\n}\nfunction _heapify2(i) {\n  var arr = _classPrivateFieldGet(this, _arr);\n  var l = 2 * i;\n  var r = l + 1;\n  var largest = i;\n  if (l < arr.length) {\n    largest = arr[l].priority < arr[largest].priority ? l : largest;\n    if (r < arr.length) {\n      largest = arr[r].priority < arr[largest].priority ? r : largest;\n    }\n    if (largest !== i) {\n      _classPrivateMethodGet(this, _swap, _swap2).call(this, i, largest);\n      _classPrivateMethodGet(this, _heapify, _heapify2).call(this, largest);\n    }\n  }\n}\nfunction _decrease2(index) {\n  var arr = _classPrivateFieldGet(this, _arr);\n  var priority = arr[index].priority;\n  var parent;\n  while (index !== 0) {\n    parent = index >> 1;\n    if (arr[parent].priority < priority) {\n      break;\n    }\n    _classPrivateMethodGet(this, _swap, _swap2).call(this, index, parent);\n    index = parent;\n  }\n}\nfunction _swap2(i, j) {\n  var arr = _classPrivateFieldGet(this, _arr);\n  var keyIndices = _classPrivateFieldGet(this, _keyIndices);\n  var origArrI = arr[i];\n  var origArrJ = arr[j];\n  arr[i] = origArrJ;\n  arr[j] = origArrI;\n  keyIndices[origArrJ.key] = i;\n  keyIndices[origArrI.key] = j;\n}\nmodule.exports = PriorityQueue;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}