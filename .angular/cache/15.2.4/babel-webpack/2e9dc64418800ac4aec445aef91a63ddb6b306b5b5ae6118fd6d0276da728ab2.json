{"ast":null,"code":"import { EventEmitter, ViewContainerRef } from '@angular/core';\nimport { Subject, combineLatest } from 'rxjs';\nimport { map, takeUntil, tap } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../../../block-store.service\";\nimport * as i2 from \"./designer-block-row-fragment/designer-block-row-fragment.component\";\nconst _c0 = [\"canvas\"];\nexport let DesignerRenderBodyBlockComponent = /*#__PURE__*/(() => {\n  class DesignerRenderBodyBlockComponent {\n    /**\r\n     * Posición superior del host\r\n     */\n    get top() {\n      return this.layout ? this.layout.top : 0;\n    }\n    /**\r\n     * Posición izquierda del host\r\n     */\n    get left() {\n      return this.layout ? this.layout.left : 0;\n    }\n    /**\r\n     * Id del host\r\n     */\n    get hostId() {\n      return this.block ? this.block.uuid : '';\n    }\n    /**\r\n     * Clases que se asocian al host\r\n     */\n    get class() {\n      const classes = [];\n      if (this.focused) {\n        classes.push('block-focused');\n      }\n      ;\n      if (this.openForConnection) {\n        classes.push('open-for-connection');\n      }\n      ;\n      if (this.closedForConnection) {\n        classes.push('closed-for-connection');\n      }\n      ;\n      return classes.join(' ').trim();\n    }\n    /**\r\n     * Bloque para renderizar\r\n    */\n    set blockContent(block) {\n      /** Almacenamos el bloque para usarlo en el template */\n      this.block = block;\n      /** Notificamos que ya tenemos el bloque asignado */\n      this.newBlock$.next(block);\n    }\n    /**\r\n     * Layout del bloque para renderizar\r\n    */\n    set layoutContent(layout) {\n      /** Almacenamos el bloque para usarlo en el template */\n      this.layout = layout;\n      /** Notificamos que ya tenemos el bloque asignado */\n      this.newLayout$.next(layout);\n    }\n    constructor(blockStore, componentFactory, changeDetectorRef) {\n      this.blockStore = blockStore;\n      this.componentFactory = componentFactory;\n      this.changeDetectorRef = changeDetectorRef;\n      /**\r\n       * Subject para manejar destrucción del objeto\r\n      */\n      this.componentDestroyed$ = new Subject();\n      /**\r\n       * Stream para reportar la inicialización\r\n      */\n      this.initialized$ = new Subject();\n      /**\r\n       * Stream para que llegó un nuevo bloque\r\n      */\n      this.newBlock$ = new Subject();\n      /**\r\n       * Stream para notificar que llegó un nuevo layout\r\n      */\n      this.newLayout$ = new Subject();\n      /**\r\n       * Bandera para indicar si está \"abierto\"\r\n       * para recibir una conexión\r\n       * Se enciende cuándo se hace dragado de la conexión\r\n      */\n      this.openForConnection = false;\n      /**\r\n       * Bandera para indicar si está \"cerrado\"\r\n       * para recibir una conexión\r\n       * Se enciende cuándo se hace dragado de la conexión\r\n      */\n      this.closedForConnection = false;\n      /**\r\n       * Bandera para indicar si debe resaltarse\r\n       * Se utiliza para mostrar bloques que tienen\r\n       * alguna condición de error\r\n      */\n      this.focused = false;\n      /**\r\n       * Enviar evento para eliminar un bloque\r\n       */\n      this.delete = new EventEmitter();\n      /** Stream para insertar el bloque en el canvas */\n      this.render$ = combineLatest(this.initialized$, this.newBlock$, this.newLayout$).pipe(takeUntil(this.componentDestroyed$), tap(([initialized, block, layout]) => {\n        /** Extraemos la clase del block */\n        this.blockComponent = this.blockStore.getComponent(block.class);\n        /** Creamos el factory para el componente */\n        const factory = this.componentFactory.resolveComponentFactory(this.blockComponent);\n        /** Obtenemos referencia al contenedor del objeto block */\n        const canvas = this.canvas;\n        /** Limpiamos la vista previa para evitar que se \"sume\" a la del componente */\n        canvas.clear();\n        /** Creamos el componente */\n        const componentRef = canvas.createComponent(factory);\n        /** Asignamos el bloque */\n        componentRef.instance.block = block;\n        /** Actualizamos la vista para que se tome el cambio de datos */\n        this.changeDetectorRef.detectChanges();\n      }), map(([render, block]) => block));\n      /** Nos suscribimos al stream */\n      this.render$.subscribe();\n    }\n    ngOnInit() {\n      this.initialized$.next(null);\n    }\n    // TODO: Implementar el método real de clickToolbar\n    //       Aqui solo quería simular el eliminar\n    clickToolbar() {\n      this.delete.emit({\n        block: this.block\n      });\n    }\n  }\n  DesignerRenderBodyBlockComponent.ɵfac = function DesignerRenderBodyBlockComponent_Factory(t) {\n    return new (t || DesignerRenderBodyBlockComponent)(i0.ɵɵdirectiveInject(i1.BlockStoreService), i0.ɵɵdirectiveInject(i0.ComponentFactoryResolver), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n  DesignerRenderBodyBlockComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: DesignerRenderBodyBlockComponent,\n    selectors: [[\"ios-designer-render-body-block\"]],\n    viewQuery: function DesignerRenderBodyBlockComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 7, ViewContainerRef);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.canvas = _t.first);\n      }\n    },\n    hostVars: 7,\n    hostBindings: function DesignerRenderBodyBlockComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵhostProperty(\"id\", ctx.hostId);\n        i0.ɵɵclassMap(ctx.class);\n        i0.ɵɵstyleProp(\"top\", ctx.top, \"px\")(\"left\", ctx.left, \"px\");\n      }\n    },\n    inputs: {\n      blockDefinition: \"blockDefinition\",\n      blockContent: [\"block\", \"blockContent\"],\n      layoutContent: [\"layout\", \"layoutContent\"],\n      openForConnection: \"openForConnection\",\n      closedForConnection: \"closedForConnection\",\n      focused: \"focused\"\n    },\n    outputs: {\n      delete: \"delete\"\n    },\n    decls: 7,\n    vars: 2,\n    consts: [[1, \"block-overlay\"], [1, \"block-toolbar\", 3, \"click\"], [1, \"block-render\"], [3, \"block\", \"rowFragment\"], [\"canvas\", \"\"]],\n    template: function DesignerRenderBodyBlockComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"div\", 0);\n        i0.ɵɵelementStart(1, \"div\", 1);\n        i0.ɵɵlistener(\"click\", function DesignerRenderBodyBlockComponent_Template_div_click_1_listener($event) {\n          return ctx.clickToolbar($event);\n        });\n        i0.ɵɵtext(2, \" X \");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(3, \"div\", 2)(4, \"ios-designer-block-row-fragment\", 3);\n        i0.ɵɵelementContainer(5, null, 4);\n        i0.ɵɵelementEnd()();\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(4);\n        i0.ɵɵproperty(\"block\", ctx.block)(\"rowFragment\", ctx.blockDefinition ? ctx.blockDefinition.rowFragment : \"\");\n      }\n    },\n    dependencies: [i2.DesignerBlockRowFragmentComponent],\n    styles: [\".closed-for-connection[_nghost-%COMP%]{opacity:.4}[_nghost-%COMP%]{transition:opacity .7s ease-in-out}.jtk-dragged[_nghost-%COMP%]{box-shadow:0 10px 10px #bbbec4}[_nghost-%COMP%]{border-width:4px;border-style:dashed;border-color:transparent;position:absolute}.block-focused[_nghost-%COMP%], .block-focused[_nghost-%COMP%]:hover{border-color:var(--canvas-block-border-focused)}[_nghost-%COMP%]:hover{border-color:#ccc}[_nghost-%COMP%]:hover   .block-toolbar[_ngcontent-%COMP%]{visibility:visible}.open-in-inspector[_nghost-%COMP%]{border-color:#ccc}.open-in-inspector[_nghost-%COMP%]   .block-toolbar[_ngcontent-%COMP%]{visibility:visible}.block-toolbar[_ngcontent-%COMP%]{position:absolute;top:10px;right:10px;border:1px solid #cccccc;border-radius:4px;background-color:#f5f5f5;visibility:hidden;z-index:501;cursor:pointer}.block-overlay[_ngcontent-%COMP%]{position:absolute;inset:0;cursor:pointer;z-index:500}.block-render[_ngcontent-%COMP%]{position:static}\"]\n  });\n  return DesignerRenderBodyBlockComponent;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}