{"ast":null,"code":"module.exports = dfs;\n\n/*\n * A helper that preforms a pre- or post-order traversal on the input graph\n * and returns the nodes in the order they were visited. If the graph is\n * undirected then this algorithm will navigate using neighbors. If the graph\n * is directed then this algorithm will navigate using successors.\n *\n * If the order is not \"post\", it will be treated as \"pre\".\n */\nfunction dfs(g, vs, order) {\n  if (!Array.isArray(vs)) {\n    vs = [vs];\n  }\n  var navigation = g.isDirected() ? v => g.successors(v) : v => g.neighbors(v);\n  var orderFunc = order === \"post\" ? postOrderDfs : preOrderDfs;\n  var acc = [];\n  var visited = {};\n  vs.forEach(v => {\n    if (!g.hasNode(v)) {\n      throw new Error(\"Graph does not have node: \" + v);\n    }\n    orderFunc(v, navigation, visited, acc);\n  });\n  return acc;\n}\nfunction postOrderDfs(v, navigation, visited, acc) {\n  var stack = [[v, false]];\n  while (stack.length > 0) {\n    var curr = stack.pop();\n    if (curr[1]) {\n      acc.push(curr[0]);\n    } else {\n      if (!visited.hasOwnProperty(curr[0])) {\n        visited[curr[0]] = true;\n        stack.push([curr[0], true]);\n        forEachRight(navigation(curr[0]), w => stack.push([w, false]));\n      }\n    }\n  }\n}\nfunction preOrderDfs(v, navigation, visited, acc) {\n  var stack = [v];\n  while (stack.length > 0) {\n    var curr = stack.pop();\n    if (!visited.hasOwnProperty(curr)) {\n      visited[curr] = true;\n      acc.push(curr);\n      forEachRight(navigation(curr), w => stack.push(w));\n    }\n  }\n}\nfunction forEachRight(array, iteratee) {\n  var length = array.length;\n  while (length--) {\n    iteratee(array[length], length, array);\n  }\n  return array;\n}","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}