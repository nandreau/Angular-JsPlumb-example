{"ast":null,"code":"\"use strict\";\n\nvar _classPrivateMethodInitSpec = require(\"C:/Users/nandr/Documents/Projets taf/jsplump ex/node_modules/@babel/runtime/helpers/classPrivateMethodInitSpec.js\").default;\nvar _classPrivateFieldInitSpec = require(\"C:/Users/nandr/Documents/Projets taf/jsplump ex/node_modules/@babel/runtime/helpers/classPrivateFieldInitSpec.js\").default;\nvar _classPrivateMethodGet = require(\"C:/Users/nandr/Documents/Projets taf/jsplump ex/node_modules/@babel/runtime/helpers/classPrivateMethodGet.js\").default;\nvar _classPrivateFieldGet = require(\"C:/Users/nandr/Documents/Projets taf/jsplump ex/node_modules/@babel/runtime/helpers/classPrivateFieldGet.js\").default;\nvar _classPrivateFieldSet = require(\"C:/Users/nandr/Documents/Projets taf/jsplump ex/node_modules/@babel/runtime/helpers/classPrivateFieldSet.js\").default;\nvar DEFAULT_EDGE_NAME = \"\\x00\";\nvar GRAPH_NODE = \"\\x00\";\nvar EDGE_KEY_DELIM = \"\\x01\";\n\n// Implementation notes:\n//\n//  * Node id query functions should return string ids for the nodes\n//  * Edge id query functions should return an \"edgeObj\", edge object, that is\n//    composed of enough information to uniquely identify an edge: {v, w, name}.\n//  * Internally we use an \"edgeId\", a stringified form of the edgeObj, to\n//    reference edges. This is because we need a performant way to look these\n//    edges up and, object properties, which have string keys, are the closest\n//    we're going to get to a performant hashtable in JavaScript.\nvar _isDirected = /*#__PURE__*/new WeakMap();\nvar _isMultigraph = /*#__PURE__*/new WeakMap();\nvar _isCompound = /*#__PURE__*/new WeakMap();\nvar _label = /*#__PURE__*/new WeakMap();\nvar _defaultNodeLabelFn = /*#__PURE__*/new WeakMap();\nvar _defaultEdgeLabelFn = /*#__PURE__*/new WeakMap();\nvar _nodes = /*#__PURE__*/new WeakMap();\nvar _in = /*#__PURE__*/new WeakMap();\nvar _preds = /*#__PURE__*/new WeakMap();\nvar _out = /*#__PURE__*/new WeakMap();\nvar _sucs = /*#__PURE__*/new WeakMap();\nvar _edgeObjs = /*#__PURE__*/new WeakMap();\nvar _edgeLabels = /*#__PURE__*/new WeakMap();\nvar _nodeCount = /*#__PURE__*/new WeakMap();\nvar _edgeCount = /*#__PURE__*/new WeakMap();\nvar _parent = /*#__PURE__*/new WeakMap();\nvar _children = /*#__PURE__*/new WeakMap();\nvar _removeFromParentsChildList = /*#__PURE__*/new WeakSet();\nclass Graph {\n  // Label for the graph itself\n\n  // Defaults to be set when creating a new node\n\n  // Defaults to be set when creating a new edge\n\n  // v -> label\n\n  // v -> edgeObj\n\n  // u -> v -> Number\n\n  // v -> edgeObj\n\n  // v -> w -> Number\n\n  // e -> edgeObj\n\n  // e -> label\n\n  /* Number of nodes in the graph. Should only be changed by the implementation. */\n\n  /* Number of edges in the graph. Should only be changed by the implementation. */\n\n  constructor(opts) {\n    _classPrivateMethodInitSpec(this, _removeFromParentsChildList);\n    _classPrivateFieldInitSpec(this, _isDirected, {\n      writable: true,\n      value: true\n    });\n    _classPrivateFieldInitSpec(this, _isMultigraph, {\n      writable: true,\n      value: false\n    });\n    _classPrivateFieldInitSpec(this, _isCompound, {\n      writable: true,\n      value: false\n    });\n    _classPrivateFieldInitSpec(this, _label, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _defaultNodeLabelFn, {\n      writable: true,\n      value: () => undefined\n    });\n    _classPrivateFieldInitSpec(this, _defaultEdgeLabelFn, {\n      writable: true,\n      value: () => undefined\n    });\n    _classPrivateFieldInitSpec(this, _nodes, {\n      writable: true,\n      value: {}\n    });\n    _classPrivateFieldInitSpec(this, _in, {\n      writable: true,\n      value: {}\n    });\n    _classPrivateFieldInitSpec(this, _preds, {\n      writable: true,\n      value: {}\n    });\n    _classPrivateFieldInitSpec(this, _out, {\n      writable: true,\n      value: {}\n    });\n    _classPrivateFieldInitSpec(this, _sucs, {\n      writable: true,\n      value: {}\n    });\n    _classPrivateFieldInitSpec(this, _edgeObjs, {\n      writable: true,\n      value: {}\n    });\n    _classPrivateFieldInitSpec(this, _edgeLabels, {\n      writable: true,\n      value: {}\n    });\n    _classPrivateFieldInitSpec(this, _nodeCount, {\n      writable: true,\n      value: 0\n    });\n    _classPrivateFieldInitSpec(this, _edgeCount, {\n      writable: true,\n      value: 0\n    });\n    _classPrivateFieldInitSpec(this, _parent, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _children, {\n      writable: true,\n      value: void 0\n    });\n    if (opts) {\n      _classPrivateFieldSet(this, _isDirected, opts.hasOwnProperty(\"directed\") ? opts.directed : true);\n      _classPrivateFieldSet(this, _isMultigraph, opts.hasOwnProperty(\"multigraph\") ? opts.multigraph : false);\n      _classPrivateFieldSet(this, _isCompound, opts.hasOwnProperty(\"compound\") ? opts.compound : false);\n    }\n    if (_classPrivateFieldGet(this, _isCompound)) {\n      // v -> parent\n      _classPrivateFieldSet(this, _parent, {});\n\n      // v -> children\n      _classPrivateFieldSet(this, _children, {});\n      _classPrivateFieldGet(this, _children)[GRAPH_NODE] = {};\n    }\n  }\n\n  /* === Graph functions ========= */\n\n  /**\n   * Whether graph was created with 'directed' flag set to true or not.\n   */\n  isDirected() {\n    return _classPrivateFieldGet(this, _isDirected);\n  }\n\n  /**\n   * Whether graph was created with 'multigraph' flag set to true or not.\n   */\n  isMultigraph() {\n    return _classPrivateFieldGet(this, _isMultigraph);\n  }\n\n  /**\n   * Whether graph was created with 'compound' flag set to true or not.\n   */\n  isCompound() {\n    return _classPrivateFieldGet(this, _isCompound);\n  }\n\n  /**\n   * Sets the label of the graph.\n   */\n  setGraph(label) {\n    _classPrivateFieldSet(this, _label, label);\n    return this;\n  }\n\n  /**\n   * Gets the graph label.\n   */\n  graph() {\n    return _classPrivateFieldGet(this, _label);\n  }\n\n  /* === Node functions ========== */\n\n  /**\n   * Sets the default node label. If newDefault is a function, it will be\n   * invoked ach time when setting a label for a node. Otherwise, this label\n   * will be assigned as default label in case if no label was specified while\n   * setting a node.\n   * Complexity: O(1).\n   */\n  setDefaultNodeLabel(newDefault) {\n    _classPrivateFieldSet(this, _defaultNodeLabelFn, newDefault);\n    if (typeof newDefault !== 'function') {\n      _classPrivateFieldSet(this, _defaultNodeLabelFn, () => newDefault);\n    }\n    return this;\n  }\n\n  /**\n   * Gets the number of nodes in the graph.\n   * Complexity: O(1).\n   */\n  nodeCount() {\n    return _classPrivateFieldGet(this, _nodeCount);\n  }\n\n  /**\n   * Gets all nodes of the graph. Note, the in case of compound graph subnodes are\n   * not included in list.\n   * Complexity: O(1).\n   */\n  nodes() {\n    return Object.keys(_classPrivateFieldGet(this, _nodes));\n  }\n\n  /**\n   * Gets list of nodes without in-edges.\n   * Complexity: O(|V|).\n   */\n  sources() {\n    var self = this;\n    return this.nodes().filter(v => Object.keys(_classPrivateFieldGet(self, _in)[v]).length === 0);\n  }\n\n  /**\n   * Gets list of nodes without out-edges.\n   * Complexity: O(|V|).\n   */\n  sinks() {\n    var self = this;\n    return this.nodes().filter(v => Object.keys(_classPrivateFieldGet(self, _out)[v]).length === 0);\n  }\n\n  /**\n   * Invokes setNode method for each node in names list.\n   * Complexity: O(|names|).\n   */\n  setNodes(vs, value) {\n    var args = arguments;\n    var self = this;\n    vs.forEach(function (v) {\n      if (args.length > 1) {\n        self.setNode(v, value);\n      } else {\n        self.setNode(v);\n      }\n    });\n    return this;\n  }\n\n  /**\n   * Creates or updates the value for the node v in the graph. If label is supplied\n   * it is set as the value for the node. If label is not supplied and the node was\n   * created by this call then the default node label will be assigned.\n   * Complexity: O(1).\n   */\n  setNode(v, value) {\n    var _this$nodeCount;\n    if (_classPrivateFieldGet(this, _nodes).hasOwnProperty(v)) {\n      if (arguments.length > 1) {\n        _classPrivateFieldGet(this, _nodes)[v] = value;\n      }\n      return this;\n    }\n    _classPrivateFieldGet(this, _nodes)[v] = arguments.length > 1 ? value : _classPrivateFieldGet(this, _defaultNodeLabelFn).call(this, v);\n    if (_classPrivateFieldGet(this, _isCompound)) {\n      _classPrivateFieldGet(this, _parent)[v] = GRAPH_NODE;\n      _classPrivateFieldGet(this, _children)[v] = {};\n      _classPrivateFieldGet(this, _children)[GRAPH_NODE][v] = true;\n    }\n    _classPrivateFieldGet(this, _in)[v] = {};\n    _classPrivateFieldGet(this, _preds)[v] = {};\n    _classPrivateFieldGet(this, _out)[v] = {};\n    _classPrivateFieldGet(this, _sucs)[v] = {};\n    _classPrivateFieldSet(this, _nodeCount, (_this$nodeCount = _classPrivateFieldGet(this, _nodeCount), ++_this$nodeCount));\n    return this;\n  }\n\n  /**\n   * Gets the label of node with specified name.\n   * Complexity: O(|V|).\n   */\n  node(v) {\n    return _classPrivateFieldGet(this, _nodes)[v];\n  }\n\n  /**\n   * Detects whether graph has a node with specified name or not.\n   */\n  hasNode(v) {\n    return _classPrivateFieldGet(this, _nodes).hasOwnProperty(v);\n  }\n\n  /**\n   * Remove the node with the name from the graph or do nothing if the node is not in\n   * the graph. If the node was removed this function also removes any incident\n   * edges.\n   * Complexity: O(1).\n   */\n  removeNode(v) {\n    var self = this;\n    if (_classPrivateFieldGet(this, _nodes).hasOwnProperty(v)) {\n      var _this$nodeCount2;\n      var removeEdge = e => self.removeEdge(_classPrivateFieldGet(self, _edgeObjs)[e]);\n      delete _classPrivateFieldGet(this, _nodes)[v];\n      if (_classPrivateFieldGet(this, _isCompound)) {\n        _classPrivateMethodGet(this, _removeFromParentsChildList, _removeFromParentsChildList2).call(this, v);\n        delete _classPrivateFieldGet(this, _parent)[v];\n        this.children(v).forEach(function (child) {\n          self.setParent(child);\n        });\n        delete _classPrivateFieldGet(this, _children)[v];\n      }\n      Object.keys(_classPrivateFieldGet(this, _in)[v]).forEach(removeEdge);\n      delete _classPrivateFieldGet(this, _in)[v];\n      delete _classPrivateFieldGet(this, _preds)[v];\n      Object.keys(_classPrivateFieldGet(this, _out)[v]).forEach(removeEdge);\n      delete _classPrivateFieldGet(this, _out)[v];\n      delete _classPrivateFieldGet(this, _sucs)[v];\n      _classPrivateFieldSet(this, _nodeCount, (_this$nodeCount2 = _classPrivateFieldGet(this, _nodeCount), --_this$nodeCount2));\n    }\n    return this;\n  }\n\n  /**\n   * Sets node p as a parent for node v if it is defined, or removes the\n   * parent for v if p is undefined. Method throws an exception in case of\n   * invoking it in context of noncompound graph.\n   * Average-case complexity: O(1).\n   */\n  setParent(v, parent) {\n    if (!_classPrivateFieldGet(this, _isCompound)) {\n      throw new Error(\"Cannot set parent in a non-compound graph\");\n    }\n    if (parent === undefined) {\n      parent = GRAPH_NODE;\n    } else {\n      // Coerce parent to string\n      parent += \"\";\n      for (var ancestor = parent; ancestor !== undefined; ancestor = this.parent(ancestor)) {\n        if (ancestor === v) {\n          throw new Error(\"Setting \" + parent + \" as parent of \" + v + \" would create a cycle\");\n        }\n      }\n      this.setNode(parent);\n    }\n    this.setNode(v);\n    _classPrivateMethodGet(this, _removeFromParentsChildList, _removeFromParentsChildList2).call(this, v);\n    _classPrivateFieldGet(this, _parent)[v] = parent;\n    _classPrivateFieldGet(this, _children)[parent][v] = true;\n    return this;\n  }\n  /**\n   * Gets parent node for node v.\n   * Complexity: O(1).\n   */\n  parent(v) {\n    if (_classPrivateFieldGet(this, _isCompound)) {\n      var parent = _classPrivateFieldGet(this, _parent)[v];\n      if (parent !== GRAPH_NODE) {\n        return parent;\n      }\n    }\n  }\n\n  /**\n   * Gets list of direct children of node v.\n   * Complexity: O(1).\n   */\n  children(v = GRAPH_NODE) {\n    if (_classPrivateFieldGet(this, _isCompound)) {\n      var children = _classPrivateFieldGet(this, _children)[v];\n      if (children) {\n        return Object.keys(children);\n      }\n    } else if (v === GRAPH_NODE) {\n      return this.nodes();\n    } else if (this.hasNode(v)) {\n      return [];\n    }\n  }\n\n  /**\n   * Return all nodes that are predecessors of the specified node or undefined if node v is not in\n   * the graph. Behavior is undefined for undirected graphs - use neighbors instead.\n   * Complexity: O(|V|).\n   */\n  predecessors(v) {\n    var predsV = _classPrivateFieldGet(this, _preds)[v];\n    if (predsV) {\n      return Object.keys(predsV);\n    }\n  }\n\n  /**\n   * Return all nodes that are successors of the specified node or undefined if node v is not in\n   * the graph. Behavior is undefined for undirected graphs - use neighbors instead.\n   * Complexity: O(|V|).\n   */\n  successors(v) {\n    var sucsV = _classPrivateFieldGet(this, _sucs)[v];\n    if (sucsV) {\n      return Object.keys(sucsV);\n    }\n  }\n\n  /**\n   * Return all nodes that are predecessors or successors of the specified node or undefined if\n   * node v is not in the graph.\n   * Complexity: O(|V|).\n   */\n  neighbors(v) {\n    var preds = this.predecessors(v);\n    if (preds) {\n      const union = new Set(preds);\n      for (var succ of this.successors(v)) {\n        union.add(succ);\n      }\n      return Array.from(union.values());\n    }\n  }\n  isLeaf(v) {\n    var neighbors;\n    if (this.isDirected()) {\n      neighbors = this.successors(v);\n    } else {\n      neighbors = this.neighbors(v);\n    }\n    return neighbors.length === 0;\n  }\n\n  /**\n   * Creates new graph with nodes filtered via filter. Edges incident to rejected node\n   * are also removed. In case of compound graph, if parent is rejected by filter,\n   * than all its children are rejected too.\n   * Average-case complexity: O(|E|+|V|).\n   */\n  filterNodes(filter) {\n    var copy = new this.constructor({\n      directed: _classPrivateFieldGet(this, _isDirected),\n      multigraph: _classPrivateFieldGet(this, _isMultigraph),\n      compound: _classPrivateFieldGet(this, _isCompound)\n    });\n    copy.setGraph(this.graph());\n    var self = this;\n    Object.entries(_classPrivateFieldGet(this, _nodes)).forEach(function ([v, value]) {\n      if (filter(v)) {\n        copy.setNode(v, value);\n      }\n    });\n    Object.values(_classPrivateFieldGet(this, _edgeObjs)).forEach(function (e) {\n      if (copy.hasNode(e.v) && copy.hasNode(e.w)) {\n        copy.setEdge(e, self.edge(e));\n      }\n    });\n    var parents = {};\n    function findParent(v) {\n      var parent = self.parent(v);\n      if (parent === undefined || copy.hasNode(parent)) {\n        parents[v] = parent;\n        return parent;\n      } else if (parent in parents) {\n        return parents[parent];\n      } else {\n        return findParent(parent);\n      }\n    }\n    if (_classPrivateFieldGet(this, _isCompound)) {\n      copy.nodes().forEach(v => copy.setParent(v, findParent(v)));\n    }\n    return copy;\n  }\n\n  /* === Edge functions ========== */\n\n  /**\n   * Sets the default edge label or factory function. This label will be\n   * assigned as default label in case if no label was specified while setting\n   * an edge or this function will be invoked each time when setting an edge\n   * with no label specified and returned value * will be used as a label for edge.\n   * Complexity: O(1).\n   */\n  setDefaultEdgeLabel(newDefault) {\n    _classPrivateFieldSet(this, _defaultEdgeLabelFn, newDefault);\n    if (typeof newDefault !== 'function') {\n      _classPrivateFieldSet(this, _defaultEdgeLabelFn, () => newDefault);\n    }\n    return this;\n  }\n\n  /**\n   * Gets the number of edges in the graph.\n   * Complexity: O(1).\n   */\n  edgeCount() {\n    return _classPrivateFieldGet(this, _edgeCount);\n  }\n\n  /**\n   * Gets edges of the graph. In case of compound graph subgraphs are not considered.\n   * Complexity: O(|E|).\n   */\n  edges() {\n    return Object.values(_classPrivateFieldGet(this, _edgeObjs));\n  }\n\n  /**\n   * Establish an edges path over the nodes in nodes list. If some edge is already\n   * exists, it will update its label, otherwise it will create an edge between pair\n   * of nodes with label provided or default label if no label provided.\n   * Complexity: O(|nodes|).\n   */\n  setPath(vs, value) {\n    var self = this;\n    var args = arguments;\n    vs.reduce(function (v, w) {\n      if (args.length > 1) {\n        self.setEdge(v, w, value);\n      } else {\n        self.setEdge(v, w);\n      }\n      return w;\n    });\n    return this;\n  }\n\n  /**\n   * Creates or updates the label for the edge (v, w) with the optionally supplied\n   * name. If label is supplied it is set as the value for the edge. If label is not\n   * supplied and the edge was created by this call then the default edge label will\n   * be assigned. The name parameter is only useful with multigraphs.\n   */\n  setEdge() {\n    var _this$edgeCount, _this$edgeCount2;\n    var v, w, name, value;\n    var valueSpecified = false;\n    var arg0 = arguments[0];\n    if (typeof arg0 === \"object\" && arg0 !== null && \"v\" in arg0) {\n      v = arg0.v;\n      w = arg0.w;\n      name = arg0.name;\n      if (arguments.length === 2) {\n        value = arguments[1];\n        valueSpecified = true;\n      }\n    } else {\n      v = arg0;\n      w = arguments[1];\n      name = arguments[3];\n      if (arguments.length > 2) {\n        value = arguments[2];\n        valueSpecified = true;\n      }\n    }\n    v = \"\" + v;\n    w = \"\" + w;\n    if (name !== undefined) {\n      name = \"\" + name;\n    }\n    var e = edgeArgsToId(_classPrivateFieldGet(this, _isDirected), v, w, name);\n    if (_classPrivateFieldGet(this, _edgeLabels).hasOwnProperty(e)) {\n      if (valueSpecified) {\n        _classPrivateFieldGet(this, _edgeLabels)[e] = value;\n      }\n      return this;\n    }\n    if (name !== undefined && !_classPrivateFieldGet(this, _isMultigraph)) {\n      throw new Error(\"Cannot set a named edge when isMultigraph = false\");\n    }\n\n    // It didn't exist, so we need to create it.\n    // First ensure the nodes exist.\n    this.setNode(v);\n    this.setNode(w);\n    _classPrivateFieldGet(this, _edgeLabels)[e] = valueSpecified ? value : _classPrivateFieldGet(this, _defaultEdgeLabelFn).call(this, v, w, name);\n    var edgeObj = edgeArgsToObj(_classPrivateFieldGet(this, _isDirected), v, w, name);\n    // Ensure we add undirected edges in a consistent way.\n    v = edgeObj.v;\n    w = edgeObj.w;\n    Object.freeze(edgeObj);\n    _classPrivateFieldGet(this, _edgeObjs)[e] = edgeObj;\n    incrementOrInitEntry(_classPrivateFieldGet(this, _preds)[w], v);\n    incrementOrInitEntry(_classPrivateFieldGet(this, _sucs)[v], w);\n    _classPrivateFieldGet(this, _in)[w][e] = edgeObj;\n    _classPrivateFieldGet(this, _out)[v][e] = edgeObj;\n    _classPrivateFieldSet(this, _edgeCount, (_this$edgeCount = _classPrivateFieldGet(this, _edgeCount), _this$edgeCount2 = _this$edgeCount++, _this$edgeCount)), _this$edgeCount2;\n    return this;\n  }\n\n  /**\n   * Gets the label for the specified edge.\n   * Complexity: O(1).\n   */\n  edge(v, w, name) {\n    var e = arguments.length === 1 ? edgeObjToId(_classPrivateFieldGet(this, _isDirected), arguments[0]) : edgeArgsToId(_classPrivateFieldGet(this, _isDirected), v, w, name);\n    return _classPrivateFieldGet(this, _edgeLabels)[e];\n  }\n\n  /**\n   * Detects whether the graph contains specified edge or not. No subgraphs are considered.\n   * Complexity: O(1).\n   */\n  hasEdge(v, w, name) {\n    var e = arguments.length === 1 ? edgeObjToId(_classPrivateFieldGet(this, _isDirected), arguments[0]) : edgeArgsToId(_classPrivateFieldGet(this, _isDirected), v, w, name);\n    return _classPrivateFieldGet(this, _edgeLabels).hasOwnProperty(e);\n  }\n\n  /**\n   * Removes the specified edge from the graph. No subgraphs are considered.\n   * Complexity: O(1).\n   */\n  removeEdge(v, w, name) {\n    var e = arguments.length === 1 ? edgeObjToId(_classPrivateFieldGet(this, _isDirected), arguments[0]) : edgeArgsToId(_classPrivateFieldGet(this, _isDirected), v, w, name);\n    var edge = _classPrivateFieldGet(this, _edgeObjs)[e];\n    if (edge) {\n      var _this$edgeCount3, _this$edgeCount4;\n      v = edge.v;\n      w = edge.w;\n      delete _classPrivateFieldGet(this, _edgeLabels)[e];\n      delete _classPrivateFieldGet(this, _edgeObjs)[e];\n      decrementOrRemoveEntry(_classPrivateFieldGet(this, _preds)[w], v);\n      decrementOrRemoveEntry(_classPrivateFieldGet(this, _sucs)[v], w);\n      delete _classPrivateFieldGet(this, _in)[w][e];\n      delete _classPrivateFieldGet(this, _out)[v][e];\n      _classPrivateFieldSet(this, _edgeCount, (_this$edgeCount3 = _classPrivateFieldGet(this, _edgeCount), _this$edgeCount4 = _this$edgeCount3--, _this$edgeCount3)), _this$edgeCount4;\n    }\n    return this;\n  }\n\n  /**\n   * Return all edges that point to the node v. Optionally filters those edges down to just those\n   * coming from node u. Behavior is undefined for undirected graphs - use nodeEdges instead.\n   * Complexity: O(|E|).\n   */\n  inEdges(v, u) {\n    var inV = _classPrivateFieldGet(this, _in)[v];\n    if (inV) {\n      var edges = Object.values(inV);\n      if (!u) {\n        return edges;\n      }\n      return edges.filter(edge => edge.v === u);\n    }\n  }\n\n  /**\n   * Return all edges that are pointed at by node v. Optionally filters those edges down to just\n   * those point to w. Behavior is undefined for undirected graphs - use nodeEdges instead.\n   * Complexity: O(|E|).\n   */\n  outEdges(v, w) {\n    var outV = _classPrivateFieldGet(this, _out)[v];\n    if (outV) {\n      var edges = Object.values(outV);\n      if (!w) {\n        return edges;\n      }\n      return edges.filter(edge => edge.w === w);\n    }\n  }\n\n  /**\n   * Returns all edges to or from node v regardless of direction. Optionally filters those edges\n   * down to just those between nodes v and w regardless of direction.\n   * Complexity: O(|E|).\n   */\n  nodeEdges(v, w) {\n    var inEdges = this.inEdges(v, w);\n    if (inEdges) {\n      return inEdges.concat(this.outEdges(v, w));\n    }\n  }\n}\nfunction _removeFromParentsChildList2(v) {\n  delete _classPrivateFieldGet(this, _children)[_classPrivateFieldGet(this, _parent)[v]][v];\n}\nfunction incrementOrInitEntry(map, k) {\n  if (map[k]) {\n    map[k]++;\n  } else {\n    map[k] = 1;\n  }\n}\nfunction decrementOrRemoveEntry(map, k) {\n  if (! --map[k]) {\n    delete map[k];\n  }\n}\nfunction edgeArgsToId(isDirected, v_, w_, name) {\n  var v = \"\" + v_;\n  var w = \"\" + w_;\n  if (!isDirected && v > w) {\n    var tmp = v;\n    v = w;\n    w = tmp;\n  }\n  return v + EDGE_KEY_DELIM + w + EDGE_KEY_DELIM + (name === undefined ? DEFAULT_EDGE_NAME : name);\n}\nfunction edgeArgsToObj(isDirected, v_, w_, name) {\n  var v = \"\" + v_;\n  var w = \"\" + w_;\n  if (!isDirected && v > w) {\n    var tmp = v;\n    v = w;\n    w = tmp;\n  }\n  var edgeObj = {\n    v: v,\n    w: w\n  };\n  if (name) {\n    edgeObj.name = name;\n  }\n  return edgeObj;\n}\nfunction edgeObjToId(isDirected, edgeObj) {\n  return edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);\n}\nmodule.exports = Graph;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}