{"ast":null,"code":"import { assign, countBy, map, filter, differenceBy, some, each, concat, compact, find, flatten, pickBy, mapValues, uniq, reverse, findIndex, reduce } from 'lodash';\nimport { Graph, alg as graphAlgorithms } from '@dagrejs/graphlib';\nimport { plumbBlockDefinitions } from './plumb-block-definitions';\n/**\r\n * Enumeración con el orden en que se puede buscar los paths de un nodo\r\n */\nvar OrderPath = /*#__PURE__*/(() => {\n  (function (OrderPath) {\n    /** Se buscan los hijos de un nodo */\n    OrderPath[\"FORWARD\"] = \"forward\";\n    /** Se buscan los padres de un nodo */\n    OrderPath[\"BACKWARD\"] = \"backward\";\n  })(OrderPath || (OrderPath = {}));\n  return OrderPath;\n})();\n/**\r\n * Esta librería se encarga de validar un flujo\r\n *\r\n */\nexport const validateFlow = (blocks, edges) => {\n  /** Convertimos los bloques y edges en un graph */\n  const g = buildGraph(blocks, edges);\n  /** Construimos el objeto con las validaciones */\n  const validations = {\n    minimunBlocks: validateMinimunBlocks(g),\n    uniqueComponent: validateUniqueComponent(g),\n    acyclic: validateAcyclic(g),\n    uniqueEntryNode: validateUniqueEntryNode(g),\n    connections: validateConnections(g),\n    nodeInEveryRoute: validateNodeInEveryRoute(g),\n    validSources: validateSources(g),\n    validSinks: validateSinks(g),\n    expiration: validateExpiration(g)\n  };\n  /** Filtramos los que tienen valid = false */\n  const errors = pickBy(validations, v => !v.valid);\n  /** Retornamos el mapa de errores y la data */\n  return mapValues(errors, v => v.data);\n};\n/**\r\n * Función para devolver todos los paths de un flujo\r\n */\nexport const getAllPaths = (blocks, edges) => {\n  /** Convertimos los bloques y edges en un graph */\n  const g = buildGraph(blocks, edges);\n  /** Buscamos todos los sources */\n  const sources = g.sources();\n  /** Buscamos los paths para cada source y los flateamos */\n  const paths = flatten(map(sources, b => extractPaths(g, b, OrderPath.FORWARD)));\n  return paths;\n};\n/**\r\n * Expresa el flujo como una lista de checkpoints\r\n */\nexport const getCheckpointCentric = (blocks, edges) => {\n  /** Convertimos los bloques y edges en un graph */\n  const graph = buildGraph(blocks, edges);\n  /** Buscamos los paths que tienen como orígen un node */\n  const paths = getPathsFromNodes(graph);\n  /** En cada path llegamos solamente hasta el próximo block del type=node */\n  const pathsCleaned = map(paths, path => filterUntilNextNode(path));\n  /** Identificamos cada path con el nodo del que parte */\n  const clustered = map(pathsCleaned, path => ({\n    block: path[0].block,\n    port: path[0].edge.split('-')[0],\n    path: path.slice(1)\n  }));\n  /** Creamos la estructura con {nodo:{port{[paths]}}} */\n  const reduced = reduce(clustered, (acum, v) => {\n    if (!acum[v.block]) {\n      acum[v.block] = {};\n    }\n    if (!acum[v.block][v.port]) {\n      acum[v.block][v.port] = [];\n    }\n    /** Extraemos únicamente el id del bloque */\n    const pathSimplified = map(v.path, b => b.block);\n    /** Agregamos el path al puerto correspoindiente */\n    acum[v.block][v.port].push(pathSimplified);\n    return acum;\n  }, {});\n  /** Calculamos las rutas que llegan al primer node */\n  /** Buscamos el primer block del tipo node */\n  const firstNode = getFirstNode(graph);\n  /** Extraemos los paths que llegan hasta el node */\n  const entryPaths = getPathsToTarget(graph, firstNode);\n  /** Extraemos sólo el id del bloque */\n  const entrySimplified = map(entryPaths, p => p = map(p, b => b.block));\n  /** Agregamos  el puerto de entrada al primer node*/\n  reduced[firstNode].in = entrySimplified;\n  /** Retornamos el mapa de nodes */\n  return reduced;\n};\n/**\r\n * Devuelve todos los paths que salen de un block de tipo=node\r\n */\nconst getPathsFromNodes = g => {\n  /** Buscamos todos los sources */\n  const all = g.nodes();\n  /** Filtramos sólo los del type node */\n  const checkpoints = filter(all, b => g.node(b) === 'node');\n  /** Buscamos los paths para cada checkopoint y los flateamos */\n  const paths = flatten(map(checkpoints, b => extractPaths(g, b, OrderPath.FORWARD)));\n  return paths;\n};\n/**\r\n * Retorna el primer node de entrada\r\n */\nconst getFirstNode = g => {\n  /** Extraemos los nodos del graph */\n  const all = g.nodes();\n  /** Agregamos los tipos */\n  const types = map(all, b => ({\n    block: b,\n    type: g.node(b)\n  }));\n  /** Filtramos sólo los de tipo start */\n  const starts = filter(types, b => b.type === 'start');\n  /** Agregamos el tipo y colocamos el orden */\n  const routes = map(starts, b => ({\n    block: b.block,\n    paths: extractPaths(g, b.block)\n  }));\n  /** Validamos que todos los paths conduzcan al mismo node */\n  const nodes = map(routes, b => ({\n    block: b.block,\n    firstNode: map(b.paths, p => extractFirstNode(p))\n  }));\n  /** Aplanamos los arreglos */\n  const flatted = flatten(map(nodes, n => n.firstNode));\n  /** Eliminamos los duplicados y compactamos */\n  const entryNodes = compact(uniq(flatted));\n  /** Si hay más de un entry Node retornamos */\n  if (entryNodes.length !== 1) {\n    console.warn('More than one entry Node; no way to obtain entry Paths');\n    return;\n  }\n  return entryNodes[0];\n};\n/**\r\n * Devuelve todos los paths que llegan a un block específico\r\n */\nconst getPathsToTarget = (g, target) => {\n  /** Extraemos los paths para el primer node */\n  const paths = extractPaths(g, target, OrderPath.BACKWARD);\n  /** Eliminamos el target (ultima posición) de todas las rutas */\n  const cleaned = map(paths, p => p.slice(0, p.length - 1));\n  return cleaned;\n};\n/**\r\n * Valida cantidad mínimas de blocks en un flujo\r\n * Cada flujo debe tener una mínima cantidad de bloques\r\n */\nconst validateMinimunBlocks = graph => {\n  /** Bloques mínimos por cada tipo */\n  const minimuns = {\n    start: 1,\n    signal: 1,\n    action: 1,\n    node: 1,\n    end: 1\n  };\n  /** Bloques existentes el graph */\n  const counter = countBy(graph.nodes(), b => graph.node(b));\n  /** Calculamos cuántos faltan */\n  const compliance = map(minimuns, (v, k) => ({\n    type: k,\n    missing: !!counter[k] ? v - counter[k] : v\n  }));\n  /** Filtramos sólo aquellos que les falta más de cero */\n  const missing = filter(compliance, v => v.missing > 0);\n  /** Retornamos los tipos que están missing */\n  return {\n    valid: missing.length === 0,\n    data: missing\n  };\n};\n/**\r\n * Valida que todos los nodos estén conectados entre ellos\r\n * En los graphs se refieren a una ruta completa como component\r\n *\r\n * {@link  https://en.wikipedia.org/wiki/Component_(graph_theory)}\r\n */\nconst validateUniqueComponent = graph => {\n  const components = graphAlgorithms.components(graph);\n  return {\n    valid: components.length === 1,\n    data: components\n  };\n};\n/**\r\n * Valida que no haya ciclo definido\r\n * Un ciclo es cuándo un grupo de nodos está conectado circularmente\r\n *\r\n * Esto evita que se pueda hacer un loop en el graph\r\n * {@link https://github.com/dagrejs/graphlib/wiki/API-Reference#alg-find-cycles}\r\n */\nconst validateAcyclic = graph => {\n  const cycles = graphAlgorithms.findCycles(graph);\n  return {\n    valid: cycles.length === 0,\n    data: cycles\n  };\n};\n/**\r\n * Valida que todas las conexiones sean válidas\r\n *\r\n * Esta protección se hace a nivel gráfico con el editor,\r\n * pero se vuelve a hacer aquí para evitar problemas con la data\r\n * que se pueieran generar directamente en el api o backend\r\n */\nconst validateConnections = graph => {\n  /** Obtenemos la lista de conexiones permitidas */\n  const allowed = plumbBlockDefinitions.allowed;\n  /** Obtenemos lista del nodos dentro del graph */\n  const edges = map(graph.edges(), e => parseEdge(e, graph.edge(e), graph));\n  /** Evaluamos cuáles conexiones son inválidas */\n  const invalid = differenceBy(edges, allowed, v => v.source.type + v.source.port + '>' + v.target.type + v.target.port);\n  /** Si hay alguno retornamos inválido */\n  return {\n    valid: invalid.length === 0,\n    data: invalid\n  };\n};\n/**\r\n * Valida que los sources sean del tipo start\r\n */\nconst validateSources = graph => {\n  /** Buscamos los blocks que no tienen ninguna conexión de entrada */\n  const sources = graph.sources();\n  /** Buscamos el tipo de cada bloque */\n  const mapped = map(sources, s => {\n    const type = graph.node(s);\n    return {\n      block: s,\n      type: type\n    };\n  });\n  /** Filtramos los que sean inválidos */\n  const invalid = filter(mapped, b => b.type !== 'start');\n  const invalidIds = map(invalid, b => b.block);\n  return {\n    valid: invalid.length === 0,\n    data: invalidIds\n  };\n};\n/**\r\n * Valida que los sinks sean del tipo end\r\n */\nconst validateSinks = graph => {\n  /** Buscamos los blocks que no tienen ninguna conexión de salida */\n  const sinks = graph.sinks();\n  /** Buscamos el tipo de cada bloque */\n  const mapped = map(sinks, s => {\n    const type = graph.node(s);\n    return {\n      block: s,\n      type: type\n    };\n  });\n  /** Filtramos los que sean inválidos */\n  const invalid = filter(mapped, b => b.type !== 'end');\n  const invalidIds = map(invalid, b => b.block);\n  return {\n    valid: invalid.length === 0,\n    data: invalidIds\n  };\n};\n/**\r\n * Valida que los nodos tengan una conexión por el puerto expiración\r\n */\nconst validateExpiration = graph => {\n  /** Obtenemos lista del nodos dentro del graph */\n  const all = graph.nodes();\n  /** Agregamos los tipos */\n  const types = map(all, b => ({\n    block: b,\n    type: graph.node(b)\n  }));\n  /** Filtramos sólo los de tipo espera */\n  const checks = filter(types, b => b.type === 'node');\n  /** Extraemos los edges hacia afuera */\n  const edges = map(checks, c => assign({}, c, {\n    ports: getSourcePorts(graph, c.block)\n  }));\n  const compliance = map(edges, e => ({\n    block: e.block,\n    expired: some(e.ports, p => p === 'expiration')\n  }));\n  const invalid = filter(compliance, c => !c.expired);\n  const invalidIds = map(invalid, b => b.block);\n  return {\n    valid: invalid.length === 0,\n    data: invalidIds\n  };\n};\n/**\r\n * Valida que todos los start se conecten con un node\r\n */\nconst validateNodeInEveryRoute = graph => {\n  /** Extraemos los nodos del graph */\n  const all = graph.nodes();\n  /** Agregamos los tipos */\n  const types = map(all, b => ({\n    block: b,\n    type: graph.node(b)\n  }));\n  /** Filtramos sólo los de tipo start */\n  const starts = filter(types, b => b.type === 'start');\n  /** Agregamos el tipo y colocamos el orden */\n  const routes = map(starts, b => ({\n    block: b.block,\n    paths: extractPaths(graph, b.block)\n  }));\n  const compliance = map(routes, r => ({\n    block: r.block,\n    paths: map(r.paths, p => ({\n      path: p,\n      valid: existNodeInPath(p)\n    }))\n  }));\n  const allPaths = flatten(map(compliance, c => c.paths));\n  const invalidPaths = filter(allPaths, p => !p.valid);\n  const paths = map(invalidPaths, p => p.path);\n  const pathsIds = map(paths, p => map(p, b => b.block));\n  return {\n    valid: paths.length === 0,\n    data: pathsIds\n  };\n};\n/**\r\n * Valida que todos los start apunten a un sólo Node\r\n */\nconst validateUniqueEntryNode = graph => {\n  /** Extraemos los nodos del graph */\n  const all = graph.nodes();\n  /** Agregamos los tipos */\n  const types = map(all, b => ({\n    block: b,\n    type: graph.node(b)\n  }));\n  /** Filtramos sólo los de tipo start */\n  const starts = filter(types, b => b.type === 'start');\n  /** Agregamos el tipo y colocamos el orden */\n  const routes = map(starts, b => ({\n    block: b.block,\n    paths: extractPaths(graph, b.block)\n  }));\n  /** Validamos que todos los paths conduzcan al mismo node */\n  const nodes = map(routes, b => ({\n    block: b.block,\n    firstNode: map(b.paths, p => extractFirstNode(p))\n  }));\n  /** Aplanamos los arreglos */\n  const flatted = flatten(map(nodes, n => n.firstNode));\n  /** Eliminamos los duplicados y compactamos */\n  const entryNodes = compact(uniq(flatted));\n  /** Es válido si hay 1 nodo o menos en todas las rutas */\n  return {\n    valid: entryNodes.length < 2,\n    data: entryNodes\n  };\n};\n/**\r\n * FUNCIONES AUXILIARES\r\n */\n/**\r\n * Valida que un path esté bien formado\r\n */\nconst existNodeInPath = path => {\n  /** Debe tener un node en el medio */\n  const node = find(path, p => p.type === 'node');\n  return !!node;\n};\n/**\r\n * Extrae el primer block del tipo node\r\n */\nconst filterUntilNextNode = path => {\n  /** Buscamos si existe un segundo nodo en el path */\n  const secondNode = findIndex(path, (b, i) => i > 0 && b.type === 'node');\n  /** Si existe retornamos el path hasta el segundo node */\n  return secondNode === -1 ? path : path.slice(0, secondNode + 1);\n};\n// TODO: Eliminar duplicación con el servicio plumbService\n/**\r\n * Obtiene el tipo de bloque a partir de los datos del bloque\r\n */\nconst getBlockType = blockClass => {\n  const defaultType = 'default';\n  /**\r\n   * El tipo se extrae de la clase\r\n   * flow.type.otros.valores\r\n   */\n  const pattern = /flow\\.(.+)(\\..*)?/;\n  const matches = blockClass.match(pattern);\n  /** Verificamos los resultados */\n  if (!matches || matches.length === 0) {\n    return defaultType;\n  }\n  return matches[1];\n};\n/**\r\n * Convierte bloques y edges en un graph\r\n * */\nconst buildGraph = (blocks, edges) => {\n  const g = new Graph();\n  blocks.forEach(b => g.setNode(b.uuid, getBlockType(b.class)));\n  // edges.forEach(e => g.setEdge(extractBlockId(e.source), extractBlockId(e.target),  calculateEdgeLabel(e)));\n  edges.forEach(e => g.setEdge(convertToGraphEdge(e), calculateEdgeName(e)));\n  return g;\n};\n/**\r\n * Convierte un FlowEdge a GraphEdge\r\n */\nconst convertToGraphEdge = edge => {\n  return {\n    v: edge.source.uuid,\n    w: edge.target.uuid\n  };\n};\n/**\r\n * Construye el label que se usa para identificar cada edge\r\n */\nconst calculateEdgeName = edge => {\n  return edge.source.port + '-' + edge.target.port;\n};\n/**\r\n * Extrae el primer node de un path\r\n */\nconst extractFirstNode = blocks => {\n  const node = find(blocks, b => b.type === 'node');\n  return !!node ? node.block : null;\n};\n/**\r\n * Obtiene los puertos en los que tiene una conexión un bloque\r\n */\nconst getSourcePorts = (graph, block) => {\n  const edges = graph.outEdges(block);\n  const sources = map(edges, e => parseEdge(e, graph.edge(e), graph));\n  const ports = map(sources, s => s.source.port);\n  return ports;\n};\n/**\r\n * Extrae los paths que existen en un graph\r\n *\r\n * está inspirada en el método Deep First Search\r\n * {@link https://github.com/dagrejs/graphlib/blob/master/lib/alg/dfs.js}\r\n */\nconst extractPaths = (graph, block, order = OrderPath.FORWARD) => {\n  /**\r\n   * Verificamos que  sea aciclico\r\n   * Este algoritmo sólo funciona para gráficos sin ciclos (DAG)\r\n  */\n  if (!graphAlgorithms.isAcyclic(graph)) {\n    return;\n  }\n  /** Inicializamos las variables qe se usan en la función recursiva */\n  const paths = [];\n  const currentPath = [];\n  /** Llamamos a la función recursiva */\n  explorePaths(graph, block, order, currentPath, paths);\n  /** Agregamos el nodo como primer bloque en todas las rutas */\n  const completePaths = map(paths, p => p[0] === block ? p : concat([block], p));\n  /** Ordenamos los bloques para que siempre queden en la dirección correcta */\n  const ordered = map(completePaths, p => order === OrderPath.FORWARD ? p : reverse(p));\n  /** Agregamos tipo y orden */\n  const typed = map(ordered, p => map(p, (n, i) => ({\n    block: n,\n    type: graph.node(n),\n    order: i,\n    edge: i < p.length - 1 ? graph.edge(p[i], p[i + 1]) : ''\n  })));\n  /** Retornamos el arreglo de paths */\n  return typed;\n};\n/**\r\n * Recorre los paths desde un nodo\r\n * Esta función es recursiva\r\n *\r\n * Como estamos seguros que no es un ciclo,\r\n * no almacenamos los nodos visitados\r\n */\nconst explorePaths = (g, v, order, current, paths) => {\n  /** Verificamos que no se quede pegado en un ciclo */\n  if (Object.keys(current).length > g.nodes().length) {\n    console.warn('Maximun nodes in graph; cant be processed');\n    return;\n  }\n  /** Guardamos el elemento en la ruta actual */\n  current.push(v);\n  /** Buscamos los hijos */\n  // const children = g.successors(v);\n  const children = order === OrderPath.FORWARD ? g.successors(v) : g.predecessors(v);\n  /** Recorremos los hijos */\n  each(children, w => {\n    explorePaths(g, w, order, current, paths);\n  });\n  /** Si es una hoja (no hijos) es una ruta completa */\n  if (children.length === 0) {\n    paths.push(current.slice());\n  }\n  /** Extraemos el elemento de la ruta actual */\n  current.pop();\n};\n/**\r\n * Convierte la información de un graph edge\r\n * en el formato\r\n * {source: {type, port}, target: {type, port}}\r\n */\nconst parseEdge = (edge, label, graph) => {\n  const splited = label.split('-');\n  const portSource = splited[0];\n  const portTarget = splited.length > 0 ? splited[1] : '';\n  const typeSource = graph.node(edge.v);\n  const typeTarget = graph.node(edge.w);\n  return {\n    source: {\n      block: edge.v,\n      type: typeSource,\n      port: portSource\n    },\n    target: {\n      block: edge.w,\n      type: typeTarget,\n      port: portTarget\n    }\n  };\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}