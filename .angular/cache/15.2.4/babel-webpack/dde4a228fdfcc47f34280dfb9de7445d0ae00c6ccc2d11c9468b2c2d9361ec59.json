{"ast":null,"code":"import { Subject } from 'rxjs';\nimport { jsPlumb } from 'jsplumb';\nimport { uniq, intersection, map as lodashMap, difference, filter, find, assign, differenceBy, get, reject } from 'lodash';\nimport { FlowPortType } from './models';\nimport { plumbBlockDefinitions } from './plumb-block-definitions';\nimport * as i0 from \"@angular/core\";\n/**\r\n * Valores que se usan para las conexiones\r\n */\nconst connectorDefaults = {\n  bezier: ['Bezier', {\n    curviness: 150\n  }],\n  flowchart: [\"Flowchart\", {\n    gap: 0,\n    cornerRadius: 5,\n    alwaysRespectStubs: false\n  }],\n  straight: ['Straight', {}],\n  'statemachine': ['StateMachine', {\n    curviness: 5\n  }]\n};\n/**\r\n * Flecha utilizada para overlay\r\n */\nconst arrowOverlay = ['Arrow', {\n  location: 1,\n  width: 15,\n  length: 15,\n  foldback: 0.9\n}];\n/**\r\n *  Defaults para jsplumb\r\n * ver {@link http://jsplumb.github.io/jsplumb/defaults.html}\r\n */\nconst plumbDefaults = {\n  Connector: connectorDefaults.flowchart,\n  ConnectionsDetachable: false,\n  ConnectionOverlays: [arrowOverlay]\n};\n/**\r\n * Parámetros que se usan por defecto\r\n * para los targets\r\n */\nconst targetDefaultOpts = {\n  isSource: false,\n  isTarget: true,\n  endpoint: ['Blank', {\n    radius: 1\n  }],\n  anchor: [\n  // Left\n  [0, 0.5, -1, 0],\n  // Right\n  [1, 0.5, 1, 0],\n  // Top\n  [0.5, 0, 0, -1],\n  // Bottom\n  [0.5, 1, 0, 1]],\n  createEndpoint: true,\n  uniqueEndpoint: false,\n  deleteEndpointsOnDetach: false\n};\n/**\r\n * Parámetros que se usan por defecto\r\n * para los targets\r\n */\nconst sourceDefaultOpts = {\n  isSource: true,\n  isTarget: false,\n  endpoint: ['Dot', {\n    radius: 7\n  }],\n  connectorStyle: {\n    strokeWidth: 4\n  },\n  anchor: [\n  // Bottom\n  [0.5, 1, 0, 1, 0, -12],\n  // Left\n  [0, 0.5, -1, 0, 12, 0],\n  // Right\n  [1, 0.5, 1, 0, -12, 0],\n  // Top\n  [0.5, 0, 0, -1, 0, 12]],\n  maxConnections: 1\n};\n/**\r\n * Tiempo que dura la animación para crear/destruir una connection\r\n * expresada en milisegundos\r\n */\nconst ANIMATE_CONNECTION_TIME = 500;\n/**\r\n * Algunos tips sobre jsplumbInstance:\r\n *\r\n * Con el método getManagedElements() se obtiene la lista de elementos \"manejados\"\r\n * que es un mapa con los ids de cada \"bloque\"\r\n */\nexport let PlumbService = /*#__PURE__*/(() => {\n  class PlumbService {\n    /**\r\n     * Constructor del servicio\r\n     */\n    constructor() {\n      /**\r\n       * Stream para notificar una nueva conexión\r\n       */\n      this.connectionAdded$ = new Subject();\n      /**\r\n       * Stream para notificar eliminación de conexión\r\n       */\n      this.connectionDetached$ = new Subject();\n      /**\r\n       * Stream para notificar el comienzo del dragado\r\n      */\n      this.dragStart$ = new Subject();\n      /**\r\n       * Stream para notificar el comienzo del dragado\r\n      */\n      this.dragStop$ = new Subject();\n      /**\r\n       * Stream para manejar el cambio de posicion de un bloque\r\n      */\n      this.changePosition$ = new Subject();\n      this.jsPlumbInstance = jsPlumb.getInstance(plumbDefaults);\n      /** Establecemos los bindings con los eventos */\n      /** Evento para creación de connection */\n      this.jsPlumbInstance.bind('connection', (info, mouseEvent) => this.handlerConnectionAdded(info, mouseEvent));\n      /** Evento para detach de connection */\n      this.jsPlumbInstance.bind('connectionDetached', (info, mouseEvent) => this.handlerConnectionDetached(info, mouseEvent));\n      /** Al hacer click sobre la conexión se elimina */\n      this.jsPlumbInstance.bind('click', conn => this.handlerClickConnection(conn));\n    }\n    /**\r\n     * Maneja el evento de agregar una conexión a jsplumb\r\n     */\n    handlerConnectionAdded(info, mouseEvent) {\n      const edge = this.convertToEdge(info.connection);\n      this.connectionAdded$.next({\n        edge: edge,\n        type: mouseEvent ? 'user' : 'programmatic'\n      });\n    }\n    /**\r\n     * Convierte una conexión de jsplumb\r\n     * en un edge de flujo\r\n     */\n    convertToEdge(conn) {\n      const uuids = conn.getUuids();\n      const sourcePortId = uuids[0];\n      const targetPortId = uuids[1];\n      return {\n        source: {\n          uuid: this.getElementId(sourcePortId),\n          port: this.getPortType(sourcePortId)\n        },\n        target: {\n          uuid: this.getElementId(targetPortId),\n          port: this.getPortType(targetPortId)\n        }\n      };\n    }\n    /**\r\n     * Maneja el evento de detachar una conexión en jsplumb\r\n     */\n    handlerConnectionDetached(info, mouseEvent) {\n      const edge = this.convertToEdge(info.connection);\n      /**\r\n       * Se utiliza un timeout para eliminar realmente las conexiones\r\n       * por tanto todas las conexiones vienen sin mouseEvent\r\n       * pero no hay eliminaciones \"programáticas\"\r\n       */\n      this.connectionDetached$.next({\n        edge: edge,\n        type: 'user'\n      });\n    }\n    /**\r\n     * Sincroniza los elementos definidos en jsplumb\r\n     * con una lista de bloques y conexiones\r\n     */\n    sync(blocks, connections) {\n      const instance = this.jsPlumbInstance;\n      /** Extraemos los ids para manejarlos fácilmente */\n      const newList = lodashMap(blocks, b => b.uuid);\n      /** Buscamos la lista de bloques manejados por jsplumb */\n      const inPlumb = lodashMap(this.jsPlumbInstance.getManagedElements(), (v, k) => k);\n      /** Buscamos los bloques en plum que NO están en la lista */\n      const deleteFromPlumb = difference(inPlumb, newList);\n      /** Buscamos los bloques en la lista NO están en plumb */\n      const addToPlumb = difference(newList, inPlumb);\n      /** Convertimos la lista de ids en lista de bloques */\n      const blocksToAdd = filter(blocks, b => addToPlumb.indexOf(b.uuid) > -1);\n      /**\r\n       * Suspendemos el drawing\r\n       */\n      instance.setSuspendDrawing(true);\n      instance.setSuspendEvents(true);\n      /** Configuramos los nuevos bloques */\n      blocksToAdd.forEach(b => {\n        /** Agregamos endpoints */\n        this.configureBlock(b.uuid, b.class);\n        /** Hacemos dragables los bloques */\n        this.draggable(b.uuid);\n      });\n      /** Eliminamos los bloques sobrantes */\n      deleteFromPlumb.forEach(b => this.removeElement(b));\n      /** Agregamos connexiones */\n      if (blocks && blocks.length > 0) {\n        connections.forEach(conn => this.addConnection(conn));\n      }\n      /** Retomar el drawing */\n      instance.setSuspendEvents(false);\n      instance.setSuspendDrawing(false, true);\n    }\n    /**\r\n     * Se encarga de repintar las conexiones y anchors\r\n     * Se debe ejecutar cada vez que se carga nuevamente las definiciones\r\n     */\n    repaintEverything() {\n      this.jsPlumbInstance.repaintEverything(true);\n    }\n    /**\r\n     * Establece el contenedor en el que viven\r\n     * los objetos administrados por Plumb\r\n     */\n    setContainer(container) {\n      this.jsPlumbInstance.setContainer(container);\n    }\n    /**\r\n     *  Notifica a jsPlumb el nivel de zooming\r\n     */\n    setZoom(zoomLevel) {\n      this.jsPlumbInstance.setZoom(zoomLevel);\n    }\n    /**\r\n     * Cambia el tipo de connector utilizado\r\n     * Se actualizan las conexiones creadas\r\n     * y se cambia el valor default\r\n     */\n    setConnectorType(type) {\n      // TODO: Mover estos defaults fuera a un archivo de configuration\n      const newConnector = connectorDefaults[type.toLocaleLowerCase()];\n      /** Establecemos el default para próximas conexiones */\n      this.jsPlumbInstance.importDefaults({\n        Connector: newConnector\n      });\n      /** Obtenemos las conexiones actuales */\n      const connections = this.jsPlumbInstance.select();\n      /** Recorremos las conexiones para hacer el cambio */\n      connections.each(c => {\n        /** Quitamos la clase que anima la conexión */\n        c.removeClass('programatic-connector');\n        /** Agregamos la marca que anima la eliminación */\n        c.addClass('connection-marked-for-delete');\n        /** Estalecemos los parámetros de animación para eliminarla */\n        this.setAnimationStyle(c);\n        /** Esperamos que se cumpla el tiempo de animación para expandirlas */\n        setTimeout(() => {\n          /** Quitamos la clase que anima la eliminacion */\n          c.removeClass('connection-marked-for-delete');\n          /** Agregamos la clase que anima el crecimiento */\n          c.addClass('programatic-connector');\n          /** Cambiamos el tipo de conector */\n          c.setConnector(newConnector);\n          /** agregamos la flecha */\n          c.addOverlay(arrowOverlay);\n          /** Estalecemos los parámetros de animación para expandirla */\n          this.setAnimationStyle(c);\n        }, ANIMATE_CONNECTION_TIME);\n      });\n    }\n    /**\r\n     * Agrega una conexión\r\n     */\n    addConnection($event) {\n      const connected = this.jsPlumbInstance.select();\n      const sourcePortId = this.getPortUuid($event.source.uuid, $event.source.port);\n      const targetPortId = this.getPortUuid($event.target.uuid, $event.target.port);\n      let exist = false;\n      connected.each(conn => {\n        const uuids = conn.getUuids();\n        if (uuids[0] === sourcePortId && uuids[1] === targetPortId) {\n          exist = true;\n        }\n      });\n      if (exist) {\n        return;\n      }\n      /**\r\n       * Buscamos si existe algún target que no tenga creado sus endpoints\r\n       * Esto se hace para poder usar el connect por uuids\r\n       * que requiere que los endpoints estén creados\r\n      */\n      /** Extraemos el elementId del puertoId del target */\n      const elementTarget = $event.target.uuid;\n      /** Buscamos la definición para el endpoint */\n      const managed = get(this.jsPlumbInstance.targetEndpointDefinitions, elementTarget + '.default.def', null);\n      if (managed && managed.createEndpoint === false) {\n        this.jsPlumbInstance.addEndpoint(elementTarget, managed);\n      }\n      /** Si llegamos hasta aqui la conexion no existe y se agrega */\n      const conn = this.jsPlumbInstance.connect({\n        uuids: [sourcePortId, targetPortId],\n        cssClass: 'programatic-connector'\n      });\n      /** Asignamos los estilos para animar la conexion */\n      this.setAnimationStyle(conn);\n    }\n    /**\r\n     * Elimina una conexión pero primero agrega una clase\r\n     * y espera unos ms para que se anime la eliminación\r\n     */\n    handlerClickConnection(conn) {\n      /** Asignamos los estilos para que se pueda animar*/\n      this.setAnimationStyle(conn);\n      conn.addClass('connection-marked-for-delete');\n      /** Esperemos que e ejecute la animación */\n      setTimeout(() => this.jsPlumbInstance.deleteConnection(conn), ANIMATE_CONNECTION_TIME);\n    }\n    /**\r\n     *  Asigna los estilos para que se pueda animar el path\r\n     */\n    setAnimationStyle(conn) {\n      if (!conn) {\n        return;\n      }\n      /**\r\n       * Hacemos un timeout para garantizar\r\n       * los path ya estén creados en el DOM\r\n       */\n      setTimeout(() => {\n        /** Obtenemos el conector */\n        const connector = conn.getConnector();\n        /** Si no obtenemos el connector, salimos */\n        if (!connector) {\n          return;\n        }\n        /** Obtenemos el lenth redondeado */\n        const len = Math.round(connector.getLength());\n        /** Obtenemos el elemento svg path */\n        const path = connector.path;\n        /** Propiedades para animar el path */\n        path.style.strokeDasharray = len;\n        path.style.strokeDashoffset = len;\n        path.style.animationDuration = ANIMATE_CONNECTION_TIME + 'ms';\n      });\n    }\n    /**\r\n     * Hace que un elemento sea draggable\r\n     * en un grid de 10x10\r\n     * y que emita un evento en cada cambio de posición\r\n     */\n    draggable(elementId, optionsUser) {\n      const optionsDefault = {\n        grid: [10, 10],\n        containment: true,\n        stop: event => this.changePosition$.next({\n          blockid: elementId,\n          left: event.finalPos[0],\n          top: event.finalPos[1]\n        })\n      };\n      const options = Object.assign(Object.assign({}, optionsDefault), optionsUser);\n      this.jsPlumbInstance.draggable(elementId, options);\n    }\n    /**\r\n     * Se encarga de configurar un bloque para plumb\r\n     */\n    configureBlock(elementId, blockClass) {\n      /** Verificamos si ya está configurado */\n      if (this.isBlockManaged(elementId)) {\n        return;\n      }\n      /** Buscamos el tipo de bloque */\n      const blockType = this.getBlockType(blockClass);\n      /** Cargamos la definición de plumb para este tipo de bloques */\n      const plumbDefinition = this.getBlockPlumbing(elementId, blockType);\n      if (!plumbDefinition) {\n        console.log('Definition not found for type:', blockClass);\n        return;\n      }\n      /** Hacemos el objeto Target */\n      this.jsPlumbInstance.makeTarget(elementId, plumbDefinition.target, targetDefaultOpts);\n      /** Agregamos los endpoints */\n      plumbDefinition.endpoints.forEach(pt => {\n        this.jsPlumbInstance.addEndpoint(elementId, pt, sourceDefaultOpts);\n      });\n    }\n    /**\r\n     * Verifica si un blockId ya está configurado en jsplumb\r\n     */\n    isBlockManaged(elementId) {\n      /** Verificamos si ya está configurado */\n      const configured = this.jsPlumbInstance.selectEndpoints();\n      let blockReady = false;\n      configured.each(pt => {\n        if (pt.elementId === elementId) {\n          return true;\n        }\n      });\n      return false;\n    }\n    /**\r\n     * Busca configuración del plumbing de un bloque\r\n     */\n    getBlockPlumbing(elementId, blockType) {\n      /** Buscamos la definición del Plumb para este bloque  */\n      const definition = find(plumbBlockDefinitions.blocks, d => d.type === blockType);\n      const allowedConnections = plumbBlockDefinitions.allowed;\n      if (!definition) {\n        console.warn('Block plumbing definition not found for type ' + blockType);\n        return;\n      }\n      /**\r\n       * Calculamos el targetDefinition\r\n       */\n      /** Calculamos el scope para el target */\n      const scope = this.getTargetScope(blockType, definition.target.port, allowedConnections);\n      /** Calculamos el id del puerto */\n      const uuid = this.getPortUuid(elementId, definition.target.port);\n      /** Calculamos la clase que se le agrega */\n      const cssClass = this.calculateCssClass(blockType, definition.target.port);\n      /** Construimos la definición completa */\n      const target = assign({}, definition.target.plumb, {\n        uuid,\n        scope\n      });\n      /**\r\n       * Calculamos los endpoints\r\n       */\n      const endpoints = lodashMap(definition.endpoints, pt => {\n        /** Calculamos el id del puerto */\n        const uuid = this.getPortUuid(elementId, pt.port);\n        /** Calculamos el scope para los endpoints */\n        const scope = this.getSourceScope(blockType, pt.port, allowedConnections);\n        /** Manejamos los eventos de dragado para las conexiones */\n        const dragOptions = {\n          start: event => this.connectionDragStart(event, elementId, scope),\n          stop: event => this.connectionDragStop(event)\n        };\n        /** Calculamos la clase que se le agrega */\n        const cssClass = this.calculateCssClass(blockType, pt.port);\n        return assign({}, pt.plumb, {\n          uuid,\n          dragOptions,\n          scope,\n          cssClass\n        });\n      });\n      /** Devolvemos la configuración completa */\n      return {\n        target,\n        endpoints\n      };\n    }\n    /**\r\n     * Calcula el scope de Target utilizado para un tipo dado\r\n     */\n    getTargetScope(blockType, port, allowed) {\n      /** Filtramos todos los permitidos que tienen como target el solicitado */\n      const filtered = filter(allowed, e => e.target.type === blockType && e.target.port === port);\n      const scopes = lodashMap(filtered, e => e.source.type + '.' + e.source.port + '->' + e.target.type + '.' + e.target.port);\n      return scopes.join(' ');\n    }\n    /**\r\n     * Calcula el scope de Source utilizado para un tipo dado\r\n     */\n    getSourceScope(blockType, port, allowed) {\n      /** Filtramos todos los permitidos que tienen como target el solicitado */\n      const filtered = filter(allowed, e => e.source.type === blockType && e.source.port === port);\n      const scopes = lodashMap(filtered, e => e.source.type + '.' + e.source.port + '->' + e.target.type + '.' + e.target.port);\n      return scopes.join(' ');\n    }\n    /**\r\n     * Calcula el uuid para un puerto\r\n     */\n    getPortUuid(elementId, port) {\n      return elementId + '.' + port;\n    }\n    /**\r\n     * Extrae el elementId desde un puerto id\r\n     */\n    getElementId(portId) {\n      return portId.split('.')[0];\n      ;\n    }\n    /**\r\n     * Extrae el tipo de puerto desde un puerto id\r\n     */\n    getPortType(portId) {\n      const splited = portId.split('.');\n      if (splited.length === 0) {\n        return FlowPortType.invalid;\n      }\n      return splited[1];\n    }\n    /**\r\n     * Calcula la clase para endpoint y target\r\n     */\n    calculateCssClass(blockType, portName) {\n      return 'endpoint-' + blockType + '-' + portName;\n    }\n    // TODO: Eliminar duplicación con función en flow-validators\n    /**\r\n     * Obtiene el tipo de bloque a partir de los datos del bloque\r\n     */\n    getBlockType(blockClass) {\n      const defaultType = 'default';\n      /**\r\n       * El tipo se extrae de la clase\r\n       * flow.type.otros.valores\r\n       */\n      const pattern = /flow\\.(.+)(\\..*)?/;\n      const matches = blockClass.match(pattern);\n      /** Verificamos los resultados */\n      if (!matches || matches.length === 0) {\n        return defaultType;\n      }\n      return matches[1];\n    }\n    /**\r\n     * Handler para el comienzo de dragado de una conexión\r\n     * Calcula cuáles bloques están \"abiertos\" / \"cerrados\"\r\n     * para recibir esa potencial conexión\r\n     *\r\n     * Se utiliza para resaltar los bloques disponibles\r\n     */\n    connectionDragStart(event, sourceId, sourceScopes) {\n      /** Buscamos la lista de todos los endpoints declarados */\n      const endpoints = this.jsPlumbInstance.selectEndpoints();\n      /** Los convertimos en un arreglo únicamente con los targets*/\n      let allBlocks = [];\n      endpoints.each(pt => {\n        if (pt.isTarget && pt.elementId !== sourceId) {\n          allBlocks.push({\n            isFull: pt.isFull(),\n            scopes: pt.scope ? pt.scope.split(' ') : '',\n            elementId: pt.elementId\n          });\n        }\n      });\n      /** Buscmaos los endpoints definidos en los targets para crearse en demanda */\n      const deferred = this.extractTargetsWithDeferredEndpoint();\n      /** Excluimos el sourceId de los deferred */\n      const deferredFiltered = reject(deferred, ['elementId', sourceId]);\n      /** Extraemos los que todavía no tenga creado el endpoint */\n      const pendings = differenceBy(deferredFiltered, allBlocks, 'elementId');\n      /** Los agregamos a la lista de todos los bloques */\n      allBlocks = allBlocks.concat(pendings);\n      /** Separamos los que están abiertos y los cerrados */\n      const open = allBlocks.filter(block => !block.isFull && intersection(sourceScopes.split(' '), block.scopes).length > 0);\n      const closed = allBlocks.filter(block => block.isFull || intersection(sourceScopes.split(' '), block.scopes).length === 0);\n      /** Extraemos los ids */\n      const openIds = open.map(b => b.elementId);\n      const closedIds = closed.map(b => b.elementId);\n      /** Notificamos el evento */\n      this.dragStart$.next({\n        open: uniq(openIds),\n        closed: uniq(closedIds)\n      });\n    }\n    /**\r\n     * Extraer los targets que tienen definidos los endpoints\r\n     * para que no se creen al momento de crear el target\r\n     */\n    extractTargetsWithDeferredEndpoint() {\n      /** Buscamos los targets definidos */\n      const targets = this.jsPlumbInstance.targetEndpointDefinitions;\n      /** Convertimos la información */\n      const potentials = lodashMap(targets, (v, k) => {\n        const scopes = v.default.def.scope ? v.default.def.scope.split(' ') : '';\n        return {\n          elementId: k,\n          scopes: scopes,\n          createEndpoint: v.default.def.createEndpoint,\n          isFull: v.default.maxConnections !== -1,\n          uuid: v.default.def.uuid\n        };\n      });\n      /** Retornamos los targets que no se crean el endpoint al principio */\n      return filter(potentials, v => !v.createEndpoint);\n    }\n    /**\r\n     * Handler para el fin de dragado de una conexión\r\n     */\n    connectionDragStop(event) {\n      this.dragStop$.next(event);\n    }\n    /**\r\n     * Implementación de remove que NO elimina\r\n     * el objeto del DOM.\r\n     * Esto lo hice para permitir que el objeto sea\r\n     * removido por angular y se puedan tener animaciones\r\n     *\r\n     * La función de remove en jsplumb\r\n     * siempre elimina del DOM y eso crea un problema con angular\r\n     * ya que se borra inmediatamente sin esperar la animación\r\n     *\r\n     * Traté de hacer todos los pasos que están en el código original para remove\r\n     * https://github.com/jsplumb/jsplumb/blob/master/src/jsplumb.js#L2824\r\n     */\n    removeElement(elementId) {\n      const instance = this.jsPlumbInstance;\n      /** Eliminamos los endpoints y conexiones */\n      instance.removeAllEndpoints(elementId, true, []);\n      /**\r\n       * Remover el elemento del drag manager\r\n       * https://github.com/jsplumb/jsplumb/issues/130\r\n       */\n      //const dragManager = instance.getDragManager();\n      //dragManager.elementRemoved(elementId);\n      /** Eliminamos el manejo de anchors asociados */\n      //instance.anchorManager.clearFor(elementId);\n      //instance.anchorManager.removeFloatingConnection(elementId);\n      /** Deshacemos los target o sources que tenga */\n      if (instance.isSource(elementId)) {\n        instance.unmakeSource(elementId);\n      }\n      if (instance.isTarget(elementId)) {\n        instance.unmakeTarget(elementId);\n      }\n      instance.destroyDraggable(elementId);\n      instance.destroyDroppable(elementId);\n      delete instance.floatingConnections[elementId];\n      /**\r\n       * Eliminamos el elemento de la lista de elementos\r\n       * manejados por jsplumb\r\n       * https://github.com/jsplumb/jsplumb/issues/815\r\n       */\n      delete instance.getManagedElements()[elementId];\n    }\n  }\n  PlumbService.ɵfac = function PlumbService_Factory(t) {\n    return new (t || PlumbService)();\n  };\n  PlumbService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: PlumbService,\n    factory: PlumbService.ɵfac\n  });\n  return PlumbService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}